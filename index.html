<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Deployed fix: remove redirect; timestamp: 2026-01-21T15:33:00Z -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home - Nems Website</title>
    <!-- Resource hints: speed up font loading -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <!-- Load fonts with preload pattern to avoid FOIT: preload the stylesheet then apply onload -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" as="style" onload="this.rel='stylesheet'">
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Ballet&display=swap" as="style" onload="this.rel='stylesheet'">
    <noscript>
        <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Ballet&display=swap" rel="stylesheet">
    </noscript>
    <!-- Preload poster for faster Largest Contentful Paint (LCP) -->
    <link rel="preload" as="image" href="/images/homeimages/homebackground-poster.jpg">
    <!-- Preload avatars (360 + 720) for faster initial paint and interactions -->
    <link rel="preload" as="image" href="/images/homeimages/fullbodyicon-360.webp" type="image/webp">
    <link rel="preload" as="image" href="/images/homeimages/fullbodyicon-720.webp" type="image/webp">

    <!-- Preload grid thumbnails (these are lightweight) -->
    <link rel="preload" as="image" href="/images/aboutmeimages/saigon.png">
    <link rel="preload" as="image" href="/images/internshipimages/tech.png">
    <link rel="preload" as="image" href="/images/leadershipimages/uf.png">
    <link rel="preload" as="image" href="/images/technicalimages/code.png">
    <link rel="preload" as="image" href="/images/creativeimages/creative.png">
    <link rel="preload" as="image" href="/images/questionsimages/questions.png">
    <!-- Critical CSS inline: minimal styles required for initial render (hero layout, basic sizes) -->
    <style>
        :root { --center-size: min(450px, 40vw); }
        *{box-sizing:border-box;margin:0;padding:0}
        html,body{height:100%}
        body{font-family:Arial, sans-serif;background:transparent;overflow:hidden}
        .center-icon{display:flex;align-items:center;justify-content:center;padding:40px}
        .center-icon img{width:var(--center-size);height:auto;display:block}
        /* ensure the poster image is visible immediately while stylesheet loads */
        #background-video{position:fixed;inset:0;object-fit:cover;z-index:-1}
    </style>

    <!-- Load visual stylesheet without blocking: preload then swap rel on load -->
    <link rel="preload" href="/css/home.css" as="style" onload="this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/css/home.css"></noscript>
    <!-- full visual CSS moved to /css/home.css and is preloaded above -->
</head>
<body>
    <!-- Movie Intro Overlay -->
    <div class="movie-intro-left" id="movieIntroLeft"></div>
    <div class="movie-intro-right" id="movieIntroRight"></div>

    <!-- Background video: lazy-load sources after first paint to improve initial load -->
    <video id="background-video" muted loop playsinline poster="images/homeimages/homebackground-poster.jpg" preload="metadata">
        <!-- sources appended by JS to avoid blocking initial render -->
        Your browser does not support the video tag.
    </video>
    <!-- Persistent cross-fade overlay used during navigation to avoid video pop/flash -->
    <div id="crossfade-overlay" style="position:fixed;inset:0;background:#000;opacity:0;pointer-events:none;transition:opacity 420ms ease-in-out;z-index:1000"></div>
    <audio id="background-music" loop preload="none">
        <source src="images/homeimages/background-music.mp3" type="audio/mpeg">
        Your browser does not support the audio tag.
    </audio>
    <audio id="smile-music" loop>
        <source src="images/homeimages/smile-music.mp3" type="audio/mpeg">
        Your browser does not support the audio tag.
    </audio>
    <div id="video-overlay"></div>
    <div class="container">
        <div class="center-icon">
            <div class="block-container block-1">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="About Me">About Me</div>
                </div>
            </div>
            
            <div class="block-container block-2">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="Internship">Internship</div>
                </div>
            </div>
            
            <div class="block-container block-3">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="Leadership">Leadership</div>
                </div>
            </div>
            
            <div class="block-container block-4">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="Technical">Technical</div>
                </div>
            </div>
            
            <div class="block-container block-5">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="Creative">Creative</div>
                </div>
            </div>
            
            <div class="block-container block-6">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="Questions">Questions</div>
                </div>
            </div>

            <!-- Lotuses around avatar head -->
            <div class="head-lotus head-lotus-left"></div>
            <div class="head-lotus head-lotus-right"></div>
            <div class="head-lotus head-lotus-middle-left"></div>
            <div class="head-lotus head-lotus-middle-right"></div>
            <div class="head-lotus head-lotus-bottom-left"></div>
            <div class="head-lotus head-lotus-bottom-right"></div>
            <div class="head-lotus head-lotus-between-1-2"></div>
            <div class="head-lotus head-lotus-between-4-5"></div>
            
            <!-- Avatar images: use WebP first with PNG fallbacks, and include width/height to avoid layout shift -->
            <picture class="avatar-normal">
                <source srcset="images/homeimages/fullbodyicon-360.webp 360w, images/homeimages/fullbodyicon-720.webp 720w" type="image/webp">
                <img src="images/homeimages/fullbodyiconclosed-transparent.png" alt="Nems Character" width="360" height="450" loading="eager" sizes="(max-width:480px) 200px, (max-width:1024px) 360px, 450px">
            </picture>
            <picture class="avatar-closed">
                <source srcset="images/homeimages/fullbodyiconclosed-360.webp 360w, images/homeimages/fullbodyiconclosed-720.webp 720w" type="image/webp">
                <img src="images/homeimages/fullbodyiconclosed-transparent.png" alt="Nems Character Closed" width="360" height="450" loading="eager" sizes="(max-width:480px) 200px, (max-width:1024px) 360px, 450px">
            </picture>
            <picture class="avatar-smile hidden">
                <source srcset="images/homeimages/fullbodyiconsmile-360.webp 360w, images/homeimages/fullbodyiconsmile-720.webp 720w" type="image/webp">
                <img src="images/homeimages/fullbodyiconsmile-transparent.png" alt="Nems Character Smile" width="360" height="450" loading="lazy" sizes="(max-width:480px) 200px, (max-width:1024px) 360px, 450px">
            </picture>
            <picture class="avatar-smile-closed hidden">
                <source srcset="images/homeimages/fullbodyiconsmileclosed-360.webp 360w, images/homeimages/fullbodyiconsmileclosed-720.webp 720w" type="image/webp">
                <img src="images/homeimages/fullbodyiconsmileclosed-transparent.png" alt="Nems Character Smile Closed" width="360" height="450" loading="lazy" sizes="(max-width:480px) 200px, (max-width:1024px) 360px, 450px">
            </picture>
            
            <div class="content-container">
                <div class="bubble-text" id="bubble-text"></div>
                
                <div class="social-links">
                    <a href="mailto:trannam18122005@gmail.com" class="social-icon email-icon" title="Email">
                    </a>
                    <a href="https://www.linkedin.com/in/nam2k5/" target="_blank" class="social-icon linkedin-icon" title="LinkedIn">
                    </a>
                    <a href="https://github.com/namtran1812" target="_blank" class="social-icon github-icon" title="GitHub">
                    </a>
                    <a href="https://drive.google.com/file/d/1uaXQkaI4neAuVnUcJ4sV0PwdZeFPL7Jn/view?usp=sharing" target="_blank" class="resume-button" title="Resume">
                        Resume
                    </a>
                </div>
            </div>
            <!-- Two-row 3-column grid revealed when avatar is clicked -->
            <div class="page-grid" id="pageGrid" aria-hidden="true">
                <div class="grid-header">choose your chapter</div>
                <!-- Each block has data-url for navigation, optional data-video for hover preview -->
                <div class="grid-block" data-url="about.html" data-video="images/aboutmeimages/aboutmebackground.mp4" tabindex="0">
                    <div class="block-inner">
                                <div class="thumb-wrapper">
                                    <picture>
                                        <source srcset="images/aboutmeimages/saigon-800.webp 800w" type="image/webp">
                                        <img class="static-thumb" src="images/aboutmeimages/saigon.png" alt="About thumbnail" loading="lazy" decoding="async">
                                    </picture>
                                </div>
                        <!-- no video preview; static image only -->
                        <div class="block-title"><span class="block-chapter">chapter 1</span> <span class="block-subtitle ballet">about me</span></div>
                    </div>
                </div>
                <div class="grid-block" data-url="internship.html" data-video="images/internshipimages/internshipbackground.mp4" tabindex="0">
                    <div class="block-inner">
                        <div class="thumb-wrapper">
                            <picture>
                                <source srcset="images/internshipimages/tech-800.webp 800w" type="image/webp">
                                <img class="static-thumb" src="images/internshipimages/tech.png" alt="Internship thumbnail" loading="lazy" decoding="async">
                            </picture>
                        </div>
                        <!-- no video preview; static image only -->
                        <div class="block-title"><span class="block-chapter">chapter 2</span> <span class="block-subtitle">internship</span></div>
                    </div>
                </div>
                <div class="grid-block" data-url="leadership.html" tabindex="0">
                    <div class="block-inner">
                        <div class="thumb-wrapper">
                            <picture>
                                <source srcset="images/leadershipimages/uf-800.webp 800w" type="image/webp">
                                <img class="static-thumb" src="images/leadershipimages/uf.png" alt="Leadership thumbnail" loading="lazy" decoding="async">
                            </picture>
                        </div>
                        <div class="block-title"><span class="block-chapter">chapter 3</span> <span class="block-subtitle">leadership</span></div>
                    </div>
                </div>
                <div class="grid-block" data-url="technical.html" tabindex="0">
                    <div class="block-inner">
                        <div class="thumb-wrapper">
                            <picture>
                                <source srcset="images/technicalimages/code-800.webp 800w" type="image/webp">
                                <img class="static-thumb" src="images/technicalimages/code.png" alt="Technical thumbnail" loading="lazy" decoding="async">
                            </picture>
                        </div>
                        <div class="block-title"><span class="block-chapter">chapter 4</span> <span class="block-subtitle">technical</span></div>
                    </div>
                </div>
                <div class="grid-block" data-url="creative.html" tabindex="0">
                    <div class="block-inner">
                        <div class="thumb-wrapper">
                            <picture>
                                <source srcset="images/creativeimages/creative-800.webp 800w" type="image/webp">
                                <img class="static-thumb" src="images/creativeimages/creative.png" alt="Creative thumbnail" loading="lazy" decoding="async">
                            </picture>
                        </div>
                        <div class="block-title"><span class="block-chapter">chapter 5</span> <span class="block-subtitle">creative</span></div>
                    </div>
                </div>
                <div class="grid-block" data-url="questions.html" tabindex="0">
                    <div class="block-inner">
                        <div class="thumb-wrapper">
                            <picture>
                                <source srcset="images/questionsimages/questions-800.webp 800w" type="image/webp">
                                <img class="static-thumb" src="images/questionsimages/questions.png" alt="Questions thumbnail" loading="lazy" decoding="async">
                            </picture>
                        </div>
                        <div class="block-title"><span class="block-chapter">chapter 6</span> <span class="block-subtitle">questions</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- audio control UI removed from page (volume button hidden) -->
    <!-- Intro overlay: shows the name in Ballet font on black, then blurs/fades to the page -->
    <div id="intro-overlay" aria-hidden="true">
        <div class="intro-center">
            <div class="intro-name"><span class="intro-first">Nam</span> <span class="intro-last">Tran</span></div>
            <!-- Pixelated code line under the name (no caret) -->
            <div class="intro-code" aria-hidden="true">
                <span class="code-text"></span>
            </div>
        </div>
    </div>
</body>
<script>
    // --- Intro code typing helpers ---
    const introTypingTimers = [];
    function clearIntroTypingTimers() {
        while (introTypingTimers.length) {
            const id = introTypingTimers.pop();
            try { clearTimeout(id); } catch(e) {}
        }
    }

    function runIntroCodeSequence(startDelay = 900) {
        const overlay = document.getElementById('intro-overlay');
        if (!overlay) return;
    const codeEl = overlay.querySelector('.intro-code .code-text');
    if (!codeEl) return;

        const prefix = 'print("';
    const innerA = 'xin chào';
        const suffix = '")';
    const innerB = 'hello world';

        const fullA = prefix + innerA + suffix; // print("Xin chao")

        const typeSpeed = 70; // ms per char
        const deleteSpeed = 60;

        // Helper: type a string into codeEl, returns promise-like via timeouts
        function typeString(str, delayBefore = 0, cb) {
            let i = 0;
            const t = setTimeout(function step(){
                if (i < str.length) {
                    codeEl.textContent += str[i++];
                    introTypingTimers.push(setTimeout(step, typeSpeed));
                } else if (typeof cb === 'function') cb();
            }, delayBefore);
            introTypingTimers.push(t);
        }

        // Helper: delete N characters from just before the suffix (keep suffix intact)
        function deleteInner(count, delayBefore = 0, cb) {
            const t = setTimeout(function step(){
                // Ensure suffix stays; if not present, just trim from end
                let txt = codeEl.textContent || '';
                if (txt.endsWith(suffix)) {
                    // remove one char before the suffix
                    if (count > 0) {
                        const withoutSuffix = txt.slice(0, -suffix.length);
                        const newWithout = withoutSuffix.slice(0, -1);
                        codeEl.textContent = newWithout + suffix;
                        count--;
                        introTypingTimers.push(setTimeout(step, deleteSpeed));
                    } else if (typeof cb === 'function') cb();
                } else {
                    // fallback: pop characters from the end
                    if (count > 0 && txt.length > 0) {
                        codeEl.textContent = txt.slice(0, -1);
                        count--;
                        introTypingTimers.push(setTimeout(step, deleteSpeed));
                    } else if (typeof cb === 'function') cb();
                }
            }, delayBefore);
            introTypingTimers.push(t);
        }

        // Start the sequence after a short delay so the name reveal is visible first
        introTypingTimers.push(setTimeout(() => {
            codeEl.textContent = '';
            // Type the whole first variant
            typeString(fullA, 0, () => {
                // small pause, then delete only the inner 'Xin chao'
                introTypingTimers.push(setTimeout(() => {
                    deleteInner(innerA.length, 0, () => {
                        // after deletion, type the new inner text INSIDE the quotes
                        try {
                            codeEl.textContent = prefix; // reset to 'print("'
                        } catch(e) {}
                        typeString(innerB, 120, () => {
                            // append the suffix after the inner text so the final string is print("...")
                            try { codeEl.textContent = (codeEl.textContent || '') + suffix; } catch(e) {}
                            // After a short pause, replace the plain text with styled spans so we can reduce the "print(" font
                            introTypingTimers.push(setTimeout(() => {
                                try {
                                    const esc = (s) => String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                                    const innerEsc = esc(innerB);
                                    codeEl.innerHTML = `<span class="code-prefix">print(</span><span class="code-quote">"</span><span class="code-inner">${innerEsc}</span><span class="code-quote">"</span><span class="code-suffix">)</span>`;
                                } catch(e) { /* ignore */ }
                            }, 500));
                        });
                    });
                }, 700));
            });
        }, startDelay));
    }

    const avatarNormal = document.querySelector('.avatar-normal');
    const avatarClosed = document.querySelector('.avatar-closed');
    const avatarSmile = document.querySelector('.avatar-smile');
    const avatarSmileClosed = document.querySelector('.avatar-smile-closed');
    const blocks = document.querySelectorAll('.block-container');
    const headLotuses = document.querySelectorAll('.head-lotus');
    const bubbleText = document.querySelector('.bubble-text');
    // Ensure bubbleTextElement and socialLinks are available early for showSmile/hideSmile
    // fall back to querySelector if the specific id isn't present yet
    const bubbleTextElement = document.getElementById('bubble-text') || bubbleText;
    const socialLinks = document.querySelector('.social-links') || null;
    let blocksVisible = false;
    const pageGrid = document.getElementById('pageGrid');
    const centerIcon = document.querySelector('.center-icon');

        // early handle for background video
        const backgroundVideo = document.getElementById('background-video');
        // Lazy-load video sources after first paint to avoid blocking initial render
        (function() {
            try {
                if (!backgroundVideo) return;
                window.requestAnimationFrame(() => {
                        const s1 = document.createElement('source');
                        // optimized WebM (720p)
                        s1.src = 'images/homeimages/homebackground-720.webm';
                        s1.type = 'video/webm';
                        const s2 = document.createElement('source');
                        // optimized H.264 MP4 (720p, faststart)
                        s2.src = 'images/homeimages/homebackground-720.mp4';
                        s2.type = 'video/mp4';
                    backgroundVideo.appendChild(s1);
                    backgroundVideo.appendChild(s2);
                    // start loading and attempt autoplay (silent) if allowed
                        backgroundVideo.load();
                        // ensure we only download the metadata initially — full downloads happen when play is allowed
                        try { backgroundVideo.preload = 'metadata'; } catch(e){}
                    backgroundVideo.play().catch(()=>{});
                });
            } catch(e) { console.debug('video lazy-load error', e); }
        })();

        // After idle, prefetch the actual video files in the background so clicking/transition is snappy
        try {
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => {
                    const link1 = document.createElement('link');
                    link1.rel = 'prefetch';
                    link1.href = 'images/homeimages/homebackground-720.webm';
                    link1.as = 'video';
                    document.head.appendChild(link1);

                    const link2 = document.createElement('link');
                    link2.rel = 'prefetch';
                    link2.href = 'images/homeimages/homebackground-720.mp4';
                    link2.as = 'video';
                    document.head.appendChild(link2);
                }, {timeout: 2000});
            } else {
                setTimeout(() => {
                    const link1 = document.createElement('link'); link1.rel = 'prefetch'; link1.href = 'images/homeimages/homebackground-720.webm'; link1.as = 'video'; document.head.appendChild(link1);
                    const link2 = document.createElement('link'); link2.rel = 'prefetch'; link2.href = 'images/homeimages/homebackground-720.mp4'; link2.as = 'video'; document.head.appendChild(link2);
                }, 2000);
            }
        } catch(e) { console.debug('prefetch setup error', e); }

    // Bubble text typing state and helper (restore typing behavior)
    const fullText = "welcome to my world.\nplease click on me to explore more about myself.";
    let currentCharIndex = 0;
    function typeNextCharacter() {
        try {
            if (currentCharIndex < fullText.length) {
                if (bubbleTextElement) bubbleTextElement.textContent += fullText[currentCharIndex];
                currentCharIndex++;
                setTimeout(typeNextCharacter, 50);
            } else {
                // show social links when done if grid not visible
                if (!blocksVisible && socialLinks) socialLinks.classList.add('visible');
            }
        } catch (e) { console.debug('typeNextCharacter error', e); }
    }

    // Social links will be revealed when the bubble typing finishes

    // Navigation mapping
    const blockNavigation = {
        'block-1': 'about.html',
        'block-2': 'internship.html',
        'block-3': 'leadership.html',
        'block-4': 'technical.html',
        'block-5': 'creative.html',
        'block-6': 'questions.html'
    };

    // Add click listeners to blocks for navigation
    document.addEventListener('click', function(e) {
        // Check if the click target is a lotus-label or lotus-block
        let closestLabel = e.target.closest('.lotus-label');
        let closestBlock = e.target.closest('.lotus-block');
        
        if (closestLabel || closestBlock) {
            // Find the parent block-container
            let blockContainer = e.target.closest('.block-container');
            
            if (blockContainer) {
                console.log('Block clicked! blocksVisible:', blocksVisible);
                
                if (blocksVisible) {
                    e.stopPropagation();
                    
                    // Glow effect disabled — no visual glow should appear on click
                    
                    // Get the block class (block-1, block-2, etc., not block-container)
                    let blockClass = null;
                    for (let cls of blockContainer.classList) {
                        if (cls.startsWith('block-') && cls !== 'block-container') {
                            blockClass = cls;
                            break;
                        }
                    }
                    
                    console.log('Block class:', blockClass, 'URL:', blockNavigation[blockClass]);
                    
                    // Navigate after cloud animation (0.2s for part1)
                    // This allows the cloud to transition smoothly to the new page
                    setTimeout(() => {
                        if (blockClass && blockNavigation[blockClass]) {
                            console.log('Navigating to:', blockNavigation[blockClass]);
                            
                            // Fade out music before navigation
                            // Show cross-fade overlay and fade out the homepage background video for a smooth transition
                            try { const overlay = document.getElementById('crossfade-overlay'); if (overlay) overlay.style.opacity = '1'; } catch(e) {}
                            try { if (backgroundVideo) backgroundVideo.style.opacity = '0'; } catch(e) {}
                            const backgroundMusic = document.getElementById('background-music');
                            const smileMusic = document.getElementById('smile-music');
                            const currentAudio = blocksVisible ? smileMusic : backgroundMusic;
                            const fadeOutDuration = 300; // 300ms fade out
                            const fadeOutInterval = 30; // Update every 30ms
                            const steps = fadeOutDuration / fadeOutInterval;
                            let currentStep = 0;
                            const originalVolume = currentAudio.volume;
                            
                            // Fade out current audio
                            const fadeOutTimer = setInterval(() => {
                                currentStep++;
                                const progress = currentStep / steps;
                                currentAudio.volume = originalVolume * (1 - progress);
                                
                                if (progress >= 1) {
                                    clearInterval(fadeOutTimer);
                                    currentAudio.pause();
                                    currentAudio.volume = originalVolume; // Reset for next page
                                    
                                    // Navigate after audio fade completes, but wait until the center icon
                                    // finishes sliding back to its original position so the UX feels synced.
                                    const navigateToRaw = blockNavigation[blockClass];
                                    if (navigateToRaw) {
                                        // append a query param so the destination page can perform a coordinated transition
                                        // Append a cache-busting timestamp so the destination page loads
                                        // a fresh copy instead of a potentially cached one.
                                        const url = navigateToRaw + (navigateToRaw.includes('?') ? '&' : '?') + 'from=home' + '&_=' + Date.now();
                                        navigateAfterSlide(url);
                                    }
                                }
                            }, fadeOutInterval);
                        }
                    }, 300);
                }
            }
        }
    });

    function showSmile() {
        console.log('showSmile() called');
        // New behavior: slide the avatar/icon to the left and reveal a static 2x3 grid
        blocksVisible = true;

        // Stop typing animation immediately (safe fallback if `fullText` is missing)
        try {
            currentCharIndex = (typeof fullText !== 'undefined') ? fullText.length : (bubbleTextElement ? bubbleTextElement.textContent.length : 0);
        } catch (e) {
            currentCharIndex = bubbleTextElement ? bubbleTextElement.textContent.length : 0;
        }

        // Hide bubble text and icons
        bubbleTextElement.textContent = '';
        if (socialLinks) {
            socialLinks.classList.remove('visible');
            socialLinks.style.opacity = '0';
        }

        // Slide the center icon left to make room for the grid
        if (centerIcon) {
            centerIcon.classList.add('slide-left');
            // Determine slide duration from CSS so JS stays in sync with the visual transition
            const cs = window.getComputedStyle(centerIcon);
            const slideDurStr = cs.getPropertyValue('--center-slide-duration') || cs.transitionDuration || '';
            // parse duration (supports s and ms)
            const parseMs = (s) => {
                if (!s) return 420;
                s = s.trim();
                if (s.endsWith('ms')) return parseFloat(s);
                if (s.endsWith('s')) return parseFloat(s) * 1000;
                return parseFloat(s) || 420;
            };
            const slideMs = parseMs(slideDurStr);
            // add grid-open after the slide animation so avatar movement is visible
            setTimeout(() => { centerIcon.classList.add('grid-open'); }, slideMs + 40);
        }

    // Add color to background and container so the page 'turns color' when grid is shown
        if (backgroundVideo) backgroundVideo.classList.add('color-mode');
        const containerEl = document.querySelector('.container');
        if (containerEl) containerEl.classList.add('color-mode');

        // Trigger avatar color blend and then swap to smile avatars
        avatarNormal.classList.add('transitioning');
        avatarClosed.classList.add('transitioning');
        avatarSmile.classList.add('transitioning');
        avatarSmileClosed.classList.add('transitioning');

        setTimeout(() => {
            try {
                avatarNormal.classList.add('hidden');
                avatarClosed.classList.add('hidden');
                avatarNormal.classList.remove('transitioning');
                avatarClosed.classList.remove('transitioning');

                avatarSmile.classList.add('visible');
                avatarSmileClosed.classList.add('visible');
                avatarSmile.classList.remove('transitioning');
                avatarSmileClosed.classList.remove('transitioning');
            } catch (e) { /* ignore if avatars missing */ }
        }, 200);

        // Reveal the grid. Position it next to the avatar to avoid clipping on odd viewports.
        if (pageGrid) {
            try {
                let left = null;
                let top = null;
                if (centerIcon) {
                    const rect = centerIcon.getBoundingClientRect();
                    // place grid to the right of the avatar with a smaller gap (closer)
                    // reduce gap from 24px to 8px so blocks appear closer to the icon
                    // Move the grid left by 40% of the viewport width
                    left = Math.round(rect.right - window.innerWidth * 0.4);
                    // vertically center the grid near the avatar
                    const gridH = pageGrid.offsetHeight || Math.round((pageGrid.offsetWidth || Math.min(740, Math.round(window.innerWidth * 0.44))) * 0.66);
                    // Move the grid 10% up
                    top = Math.round(rect.top + (rect.height / 2) - (gridH / 2) - window.innerHeight * 0.10);
                } else {
                    // Fallback: center the grid vertically and horizontally, then move up 10%
                    left = Math.round(window.innerWidth / 2);
                    top = Math.round(window.innerHeight * 0.15 - window.innerHeight * 0.10);
                }

                // Clamp to viewport so the grid is always fully visible
                const gridWidth = pageGrid.offsetWidth || Math.min(740, Math.round(window.innerWidth * 0.44));
                const maxLeft = Math.max(8, window.innerWidth - gridWidth - 8);
                left = Math.min(Math.max(8, left), maxLeft);

                const gridHeight = pageGrid.offsetHeight || Math.round(gridWidth * 0.66);
                const maxTop = Math.max(8, window.innerHeight - gridHeight - 8);
                top = Math.min(Math.max(8, top), maxTop);

                pageGrid.style.left = `${left}px`;
                pageGrid.style.top = `${top}px`;
            } catch (e) { /* ignore positioning errors */ }
            pageGrid.setAttribute('aria-hidden', 'false');
            pageGrid.classList.add('visible');
            pageGrid.style.pointerEvents = 'auto';
            pageGrid.style.zIndex = 999999;
            // Staggered reveal: header then blocks
            try {
                const header = pageGrid.querySelector('.grid-header');
                const blocksToReveal = Array.from(pageGrid.querySelectorAll('.grid-block'));
                if (header) {
                    setTimeout(() => header.classList.add('revealed'), 140);
                }
                blocksToReveal.forEach((b, i) => {
                    setTimeout(() => b.classList.add('revealed'), 260 + i * 120);
                });
            } catch (e) { /* ignore reveal errors */ }
            try { console.log('pageGrid bbox:', pageGrid.getBoundingClientRect(), 'computed opacity', window.getComputedStyle(pageGrid).opacity); } catch(e) {}
            // Diagnostic fallback: if CSS or other rules keep the grid hidden, force it visible
            setTimeout(() => {
                try {
                    const comp = window.getComputedStyle(pageGrid);
                    if (comp && (comp.display === 'none' || comp.opacity === '0' || comp.visibility === 'hidden')) {
                        console.warn('Diagnostic: pageGrid computed style after reveal:', {
                            display: comp.display,
                            opacity: comp.opacity,
                            visibility: comp.visibility,
                            left: pageGrid.style.left,
                            top: pageGrid.style.top,
                            zIndex: pageGrid.style.zIndex
                        });
                        // Force visible as a debugging aid
                        pageGrid.style.display = 'grid';
                        pageGrid.style.opacity = '1';
                        pageGrid.style.visibility = 'visible';
                        pageGrid.classList.add('visible');
                    }
                } catch (e) { console.debug('Diagnostic fallback error', e); }
            }, 220);
        }

        // Prepare hover handlers for grid blocks (play video on hover / focus)
        const gridBlocks = document.querySelectorAll('.grid-block');
        gridBlocks.forEach(g => {
            // Only toggle the active class for CSS hover/focus effects (no video playback)
            g.addEventListener('mouseenter', () => g.classList.add('active'));
            g.addEventListener('mouseleave', () => g.classList.remove('active'));
            g.addEventListener('focus', () => g.classList.add('active'));
            g.addEventListener('blur', () => g.classList.remove('active'));

            // Click navigates to the page (preserve existing audio fade behavior)
            g.addEventListener('click', (ev) => {
                ev.stopPropagation();
                const url = g.dataset.url;
                if (url) {
                    // Move icon back to original position and switch to smile/color before navigation
                    try { resetIconToSmile(); } catch(e) { console.debug('resetIconToSmile error', e); }

                    // Fade out any playing music then navigate
                    const backgroundMusic = document.getElementById('background-music');
                    const smileMusic = document.getElementById('smile-music');
                    const currentAudio = blocksVisible ? smileMusic || backgroundMusic : backgroundMusic;
                    const fadeOutDuration = 300;
                    const fadeOutInterval = 30;
                    const steps = fadeOutDuration / fadeOutInterval;
                    let currentStep = 0;
                    const originalVolume = currentAudio ? currentAudio.volume : 0.5;
                    if (currentAudio) {
                        const fadeOutTimer = setInterval(() => {
                            currentStep++;
                            const progress = currentStep / steps;
                            currentAudio.volume = originalVolume * (1 - progress);
                                if (progress >= 1) {
                                clearInterval(fadeOutTimer);
                                try { currentAudio.pause(); } catch(e){}
                                currentAudio.volume = originalVolume;
                                // Wait until the center icon finishes sliding back before navigation
                                if (url) {
                                                // Append cache-busting timestamp to avoid loading a stale cached page
                                                const urlWithParam = url + (url.includes('?') ? '&' : '?') + 'from=home' + '&_=' + Date.now();
                                                // Show cross-fade overlay and fade out the homepage background video immediately to avoid a visual pop
                                                try { const overlay = document.getElementById('crossfade-overlay'); if (overlay) overlay.style.opacity = '1'; } catch(e) {}
                                                try { if (backgroundVideo) backgroundVideo.style.opacity = '0'; } catch(e) {}
                                                navigateAfterSlide(urlWithParam);
                                            }
                            }
                        }, fadeOutInterval);
                    } else {
                        window.location.href = url;
                    }
                }
            });
        });
    }

    function hideSmile() {
        console.log('hideSmile() called');
        blocksVisible = false;
        
        // Reset typing animation and show text and icons again
    bubbleTextElement.textContent = '';
    currentCharIndex = 0;
    if (socialLinks) socialLinks.style.opacity = '';  // Remove inline style to allow CSS to take over
        
    // Fade out smile music and switch back to background music
        const backgroundMusic = document.getElementById('background-music');
        const smileMusic = document.getElementById('smile-music');
        const fadeOutDuration = 500; // 500ms fade out
        const fadeOutInterval = 50; // Update every 50ms
        const steps = fadeOutDuration / fadeOutInterval;
        let currentStep = 0;
        const originalVolume = smileMusic.volume;
        
        // Fade out smile music
        const fadeOutTimer = setInterval(() => {
            currentStep++;
            const progress = currentStep / steps;
            smileMusic.volume = originalVolume * (1 - progress);
            
            if (progress >= 1) {
                clearInterval(fadeOutTimer);
                smileMusic.pause();
                smileMusic.currentTime = 0;
                smileMusic.volume = originalVolume; // Reset volume for later
                
                // Start background music with fade in
                if (backgroundMusic) {
                    backgroundMusic.volume = 0;
                    backgroundMusic.play().catch(e => console.log('Resume audio failed:', e));
                    
                    // Fade in background music
                    let fadeInStep = 0;
                    const fadeInTimer = setInterval(() => {
                        fadeInStep++;
                        const fadeInProgress = fadeInStep / steps;
                        backgroundMusic.volume = originalVolume * fadeInProgress;
                        
                        if (fadeInProgress >= 1) {
                            clearInterval(fadeInTimer);
                            backgroundMusic.volume = originalVolume;
                        }
                    }, fadeOutInterval);
                }
            }
        }, fadeOutInterval);
        
        // Remove color from background video and container
        if (backgroundVideo) backgroundVideo.classList.remove('color-mode');
        const container = document.querySelector('.container');
        if (container) container.classList.remove('color-mode');
        
        // Immediately revert the center icon back to the black-and-white avatars
        try {
            if (avatarNormal) avatarNormal.classList.remove('hidden');
            if (avatarClosed) avatarClosed.classList.remove('hidden');
            if (avatarSmile) avatarSmile.classList.remove('visible');
            if (avatarSmileClosed) avatarSmileClosed.classList.remove('visible');
        } catch (e) { /* ignore if avatars missing */ }

        // Add color blend animation to smile avatars before hiding them
        avatarSmile.classList.add('transitioning');
        avatarSmileClosed.classList.add('transitioning');
        
        // Add color blend animation to normal avatars
        avatarNormal.classList.add('transitioning');
        avatarClosed.classList.add('transitioning');

        // Start the slide-back animation immediately and schedule typing to start after it finishes
        if (centerIcon) {
            try {
                // compute slide duration from CSS
                const cs = window.getComputedStyle(centerIcon);
                const slideDurStr = cs.getPropertyValue('--center-slide-duration') || cs.transitionDuration || '';
                const parseMs = (s) => {
                    if (!s) return 420;
                    s = s.trim();
                    if (s.endsWith('ms')) return parseFloat(s);
                    if (s.endsWith('s')) return parseFloat(s) * 1000;
                    return parseFloat(s) || 420;
                };
                const slideMs = parseMs(slideDurStr);

                // remove grid-open and slide-left to animate back to center
                centerIcon.classList.remove('grid-open');
                centerIcon.classList.remove('slide-left');

                // Start typing after the slide-back animation completes
                setTimeout(() => {
                    try { typeNextCharacter(); } catch(e) { console.debug('typeNextCharacter error after slide-back', e); }
                }, Math.max(40, slideMs + 40));
            } catch (e) {
                // fallback: start typing after a short delay
                setTimeout(() => { try { typeNextCharacter(); } catch(e) {} }, 360);
            }
        } else {
            // no center icon — just start typing after the usual short delay
            setTimeout(() => { try { typeNextCharacter(); } catch(e) {} }, 360);
        }

        // After animation completes, switch the avatars
        setTimeout(() => {
            // Show blinking normal avatars
            avatarNormal.classList.remove('hidden');
            avatarClosed.classList.remove('hidden');
            avatarNormal.classList.remove('transitioning');
            avatarClosed.classList.remove('transitioning');

            // Hide blinking smile avatars
            avatarSmile.classList.remove('visible');
            avatarSmileClosed.classList.remove('visible');
            avatarSmile.classList.remove('transitioning');
            avatarSmileClosed.classList.remove('transitioning');
            
            // Fade out lotus blocks and the page grid (header + blocks)
            try {
                blocks.forEach(block => {
                    try {
                        block.classList.add('fading-out');
                        // reverse typing then hide if that helper exists
                        const label = block.querySelector('.lotus-label');
                        if (label && typeof reverseTypeLotusLabel === 'function') {
                            try {
                                reverseTypeLotusLabel(label, 20, () => {
                                    setTimeout(() => {
                                        block.classList.remove('visible');
                                        block.classList.remove('fading-out');
                                    }, 0);
                                });
                            } catch (e) {
                                // fallback: clear and hide immediately
                                label.textContent = '';
                                setTimeout(() => { block.classList.remove('visible'); block.classList.remove('fading-out'); }, 0);
                            }
                        } else if (label) {
                            // reverseTypeLotusLabel missing: clear label and hide after fade
                            try { label.textContent = ''; } catch(e){}
                            setTimeout(() => { block.classList.remove('visible'); block.classList.remove('fading-out'); }, 260);
                        } else {
                            setTimeout(() => { block.classList.remove('visible'); block.classList.remove('fading-out'); }, 260);
                        }
                    } catch(e) {
                        // ensure one block failure doesn't stop others
                        try { block.classList.remove('visible'); block.classList.remove('fading-out'); } catch(err){}
                    }
                });

                // Fade out the page grid header and each grid-block gracefully
                const header = pageGrid ? pageGrid.querySelector('.grid-header') : null;
                const gridBlocks = pageGrid ? Array.from(pageGrid.querySelectorAll('.grid-block')) : [];
                if (header) header.classList.add('fading-out');
                gridBlocks.forEach(gb => gb.classList.add('fading-out'));

                // After the fade duration, hide the grid entirely and reset attributes
                setTimeout(() => {
                    try {
                        if (pageGrid) {
                            if (header) header.classList.remove('fading-out', 'revealed');
                            gridBlocks.forEach(gb => { gb.classList.remove('fading-out', 'revealed'); gb.classList.remove('active'); });
                            pageGrid.classList.remove('visible');
                            pageGrid.style.pointerEvents = '';
                            pageGrid.style.zIndex = '';
                            pageGrid.setAttribute('aria-hidden', 'true');
                        }
                    } catch(e) { /* ignore */ }
                }, 240);
            } catch(e) {
                console.warn('Error while fading out lotus/grid elements:', e);
                // Best-effort cleanup
                try { if (pageGrid) { pageGrid.classList.remove('visible'); pageGrid.setAttribute('aria-hidden', 'true'); } } catch(_){}
            }

            // Ensure lotus indicators are hidden
            headLotuses.forEach(lotus => lotus.classList.remove('visible'));

            // Start typing animation again (show bubble text and social links)
            // (typing is scheduled to start after slide-back completes)
    }, 320); // Match the animation duration (shortened)
        // Ensure center icon returns to normal and avatar is visible again
        if (centerIcon) { 
            centerIcon.classList.remove('grid-open');
            // remove slide-left after allowing any reverse animation so the slide back is visible
            try {
                const cs = window.getComputedStyle(centerIcon);
                const slideDurStr = cs.getPropertyValue('--center-slide-duration') || cs.transitionDuration || '';
                const parseMs = (s) => {
                    if (!s) return 420;
                    s = s.trim();
                    if (s.endsWith('ms')) return parseFloat(s);
                    if (s.endsWith('s')) return parseFloat(s) * 1000;
                    return parseFloat(s) || 420;
                };
                const slideMs = parseMs(slideDurStr);
                setTimeout(() => { centerIcon.classList.remove('slide-left'); }, Math.max(40, Math.round(slideMs / 3)));
            } catch (e) {
                setTimeout(() => { centerIcon.classList.remove('slide-left'); }, 120);
            }
        }
    }

    // Move the center icon back to its original position and show the smiling, colored avatars.
    function resetIconToSmile() {
        try {
            blocksVisible = false;
            // Move center icon back to center
            if (centerIcon) {
                centerIcon.classList.remove('grid-open');
                centerIcon.classList.remove('slide-left');
            }

            // Ensure video/container are in color mode so avatars look colored
            try { if (backgroundVideo) backgroundVideo.classList.add('color-mode'); } catch(e) {}
            const containerEl = document.querySelector('.container');
            try { if (containerEl) containerEl.classList.add('color-mode'); } catch(e) {}

            // Show smile avatars and hide normal ones
            try {
                if (avatarNormal) avatarNormal.classList.add('hidden');
                if (avatarClosed) avatarClosed.classList.add('hidden');
                if (avatarSmile) avatarSmile.classList.add('visible');
                if (avatarSmileClosed) avatarSmileClosed.classList.add('visible');
            } catch(e) { console.debug('resetIconToSmile avatar toggle error', e); }

            // Optionally start smile music if present
            try {
                const smileMusic = document.getElementById('smile-music');
                if (smileMusic) {
                    smileMusic.currentTime = 0;
                    smileMusic.play().catch(e => {/* ignore autoplay errors */});
                }
            } catch(e) {}

            // Fade out the page grid header and blocks so they disappear smoothly before navigation
            try {
                const pageGridEl = document.getElementById('pageGrid');
                if (pageGridEl) {
                    const header = pageGridEl.querySelector('.grid-header');
                    const gridBlocks = pageGridEl ? Array.from(pageGridEl.querySelectorAll('.grid-block')) : [];
                    if (header) header.classList.add('fading-out');
                    gridBlocks.forEach(gb => gb.classList.add('fading-out'));

                    // After the fade duration, clean up classes and hide the grid
                    setTimeout(() => {
                        try {
                            if (header) header.classList.remove('fading-out', 'revealed');
                            gridBlocks.forEach(gb => { gb.classList.remove('fading-out', 'revealed', 'active'); gb.classList.remove('visible'); });
                            pageGridEl.classList.remove('visible');
                            pageGridEl.style.pointerEvents = '';
                            pageGridEl.style.zIndex = '';
                            pageGridEl.setAttribute('aria-hidden', 'true');
                        } catch(e) { /* ignore cleanup errors */ }
                    }, 240);
                }
            } catch(e) { console.debug('resetIconToSmile grid fade error', e); }
        } catch(e) { console.debug('resetIconToSmile error', e); }
    }

    // Helper: navigate only after the center icon slide-back completes.
    function navigateAfterSlide(navigateTo) {
        try {
            if (!navigateTo) return;
            const center = document.querySelector('.center-icon');
            if (!center) { window.location.href = navigateTo; return; }

            const cs = window.getComputedStyle(center);
            const slideDurStr = cs.getPropertyValue('--center-slide-duration') || cs.transitionDuration || '';
            const parseMs = (s) => {
                if (!s) return 420;
                s = s.trim();
                if (s.endsWith('ms')) return parseFloat(s);
                if (s.endsWith('s')) return parseFloat(s) * 1000;
                return parseFloat(s) || 420;
            };
            const slideMs = parseMs(slideDurStr);
            // Add a small buffer to ensure the visual transition completes
            const buffer = 60;
            setTimeout(() => { window.location.href = navigateTo; }, slideMs + buffer);
        } catch (e) {
            try { window.location.href = navigateTo; } catch(_){ }
        }
    }

    // Attach click handlers only if avatars exist to avoid ReferenceErrors stopping execution
    if (avatarNormal && typeof avatarNormal.addEventListener === 'function') {
        avatarNormal.addEventListener('click', function(e) {
            e.stopPropagation();
            showSmile();
        });
    }
    if (avatarClosed && typeof avatarClosed.addEventListener === 'function') {
        avatarClosed.addEventListener('click', function(e) {
            e.stopPropagation();
            showSmile();
        });
    }
    if (avatarSmile && typeof avatarSmile.addEventListener === 'function') {
        avatarSmile.addEventListener('click', function(e) {
            e.stopPropagation();
            hideSmile();
        });
    }
    if (avatarSmileClosed && typeof avatarSmileClosed.addEventListener === 'function') {
        avatarSmileClosed.addEventListener('click', function(e) {
            e.stopPropagation();
            hideSmile();
        });
    }

    // Also allow clicking the whole center icon area to toggle the grid state
    if (centerIcon && typeof centerIcon.addEventListener === 'function') {
        centerIcon.addEventListener('click', function(e) {
            e.stopPropagation();
            if (blocksVisible) {
                hideSmile();
            } else {
                showSmile();
            }
        });
    }

    // Audio autoplay functionality (UI removed)
    // volume UI elements removed; only passive audio playback remains
    const backgroundMusic = document.getElementById('background-music');
    
    // Opening intro enabled — keep panels so the cinematic split animation can play.
    // Previously this IIFE removed the panels immediately which prevented the split from showing.
    // If you want to skip the intro panels in future, set localStorage.setItem('skipIntro','1') or
    // add logic here to remove them conditionally.
    /*
    (function removeIntroPanelsNow(){
        try {
            const introLeft = document.getElementById('movieIntroLeft');
            const introRight = document.getElementById('movieIntroRight');
            if (introLeft) introLeft.remove();
            if (introRight) introRight.remove();
        } catch (e) { console.debug('Could not remove intro panels:', e); }
    })();
    */
    
    if (backgroundMusic) {
        backgroundMusic.volume = 0.5; // Set default volume to 50%
        console.log('Audio element found:', backgroundMusic);
        
        let audioStarted = false;
        
        // Function to start audio
        function startAudio() {
            if (!audioStarted && backgroundMusic && !blocksVisible) {
                audioStarted = true;
                console.log('Starting audio...');
                const playPromise = backgroundMusic.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('Audio is now playing!');
                        })
                        .catch(error => {
                            console.log('Audio play error:', error);
                            audioStarted = false; // Reset so we can try again
                        });
                }
            }
        }
        
        // Add event listeners without 'once' so they persist
        document.addEventListener('mousemove', startAudio);
        document.addEventListener('touchstart', startAudio);
        document.addEventListener('click', startAudio);
        document.addEventListener('keydown', startAudio);
        
        // We'll start audio after the intro sequence finishes (see runIntroThenStart)
        
        // Listen for when audio ends to ensure it loops
        backgroundMusic.addEventListener('ended', () => {
            console.log('Audio ended, restarting loop');
            backgroundMusic.currentTime = 0;
            backgroundMusic.play().catch(e => console.log('Loop play failed:', e));
        });
    }

    // Ensure we start in black-and-white state (no color-mode) until user clicks
    try {
        if (backgroundVideo && !blocksVisible) backgroundVideo.classList.remove('color-mode');
        const containerEl = document.querySelector('.container');
        if (containerEl && !blocksVisible) containerEl.classList.remove('color-mode');
    } catch (e) {}

    // Intro sequence: show name overlay, then fade into the page. Start typing/audio after intro.
    function runIntroThenStart() {
        const intro = document.getElementById('intro-overlay');
        const centerIconEl = document.querySelector('.center-icon');
        try {
            if (!intro) {
                // No overlay, start immediately
                try { typeNextCharacter(); } catch(e) {}
                try { startAudio(); } catch(e) {}
                return;
            }

            // Make the center icon non-interactive while the intro runs
            try { if (centerIconEl) centerIconEl.classList.add('no-interact'); } catch(e) {}

            // Helper to run the existing intro reveal / typing / fade sequence
            function continueIntro() {
                // Staggered reveal: first name then last name
                const nameEl = intro.querySelector('.intro-name');
                if (nameEl) {
                    // Reveal first quickly
                    setTimeout(() => { nameEl.classList.add('reveal-first'); }, 200);
                    // Then reveal last shortly after
                    setTimeout(() => { nameEl.classList.add('reveal-last'); }, 600);
                }

                // Start the intro code typing after the last-name reveal transition completes
                try {
                    // reveal-last is added at ~600ms and each name part uses a 1200ms transition
                    // so wait until that transition finishes before starting the typed code to avoid layout jitter
                    const revealLastDelay = 600; // ms when reveal-last class is added
                    const nameTransitionMs = 1200; // matches CSS transition duration for the name parts
                    const buffer = 80; // small buffer so the visual settle is complete
                    setTimeout(() => {
                        try {
                            const introCodeEl = intro.querySelector('.intro-code');
                            if (introCodeEl) introCodeEl.classList.add('reveal');
                        } catch(e) {}
                        try { runIntroCodeSequence(120); } catch(e) { console.debug('runIntroCodeSequence error', e); }
                    }, revealLastDelay + nameTransitionMs + buffer);
                } catch(e) { console.debug('runIntroCodeSequence schedule error', e); }

                // Hold the fully revealed name for ~6 seconds total, then fade the overlay
                const fadeStartMs = 6000;
                const fadeDurationMs = 1800; // matches CSS transition set above
                const removalBufferMs = 120; // small buffer after fade completes before removing overlay

                setTimeout(() => {
                    // add fade class to intro so the overlay blurs/fades
                    intro.classList.add('intro-fade');

                    // Trigger movie panels to open at the moment the intro starts to fade
                    try {
                        const leftPanel = document.getElementById('movieIntroLeft');
                        const rightPanel = document.getElementById('movieIntroRight');
                        const panelAnimationMs = 2500; // should match CSS keyframe duration for openLeft/openRight
                        let panelsHandled = false;

                        const onPanelsDone = () => {
                            if (panelsHandled) return; panelsHandled = true;
                            try { if (leftPanel) leftPanel.remove(); } catch(e) {}
                            try { if (rightPanel) rightPanel.remove(); } catch(e) {}
                            // Promote overlay above UI once panels are removed so it sits on top for the remaining fade
                            try { intro.classList.add('intro-overlay-top'); } catch(e) {}
                            // Re-enable center icon interactions once panels are done
                            try { if (centerIconEl) centerIconEl.classList.remove('no-interact'); } catch(e) {}
                            // Promote the center icon above the intro overlay so avatars are visible
                            try { if (centerIconEl) centerIconEl.classList.add('icon-top'); } catch(e) {}
                        };

                        try {
                            // Add the class that runs the open animation
                            if (leftPanel) leftPanel.classList.add('open');
                            if (rightPanel) rightPanel.classList.add('open');

                            // Listen for animationend on either panel
                            if (leftPanel && leftPanel.addEventListener) leftPanel.addEventListener('animationend', onPanelsDone, { once: true });
                            if (rightPanel && rightPanel.addEventListener) rightPanel.addEventListener('animationend', onPanelsDone, { once: true });
                        } catch(e) { /* ignore */ }

                        // Fallback timeout to ensure panels are removed even if events don't fire
                        setTimeout(onPanelsDone, panelAnimationMs + 120);
                    } catch(e) { console.debug('Panel open trigger error', e); }
                }, fadeStartMs);

                // Remove overlay and start audio/typing after fade completes
                setTimeout(() => {
                    try { intro.remove(); } catch(e) { intro.style.display = 'none'; }
                    // Ensure center icon is interactive (in case panels didn't fire an event)
                    try { if (centerIconEl) centerIconEl.classList.remove('no-interact'); } catch(e) {}
                    try { startAudio(); } catch(e) {}
                    try { typeNextCharacter(); } catch(e) { console.debug('typeNextCharacter error after intro', e); }
                }, fadeStartMs + fadeDurationMs + removalBufferMs);
            }

            // Start the intro immediately; when the overlay blur/fade starts we'll trigger the panels to open
            continueIntro();
        } catch (e) {
            console.debug('Intro run error', e);
            try { typeNextCharacter(); } catch(e) {}
            try { startAudio(); } catch(e) {}
        }
    }
    // Start the intro sequence now that the function is defined
    try { runIntroThenStart(); } catch(e) { console.debug('runIntroThenStart invocation error', e); }
    
    // Volume UI removed: keeping audio playback logic but no visible controls

    // Parallax effect for grid thumbnails: nudge the image on mousemove for depth
    (function attachThumbnailParallax(){
        const blocks = document.querySelectorAll('.grid-block');
        blocks.forEach(block => {
            const img = block.querySelector('img.static-thumb');
            if (!img) return;

            let rafId = null;
            let targetX = 0, targetY = 0, targetS = 1;
            let currentX = 0, currentY = 0, currentS = 1;

            function updateVars(){
                // lerp to target for smooth, gentler motion
                currentX += (targetX - currentX) * 0.08;
                currentY += (targetY - currentY) * 0.08;
                currentS += (targetS - currentS) * 0.06;

                img.style.setProperty('--px', currentX.toFixed(2) + 'px');
                img.style.setProperty('--py', currentY.toFixed(2) + 'px');
                img.style.setProperty('--ps', currentS.toFixed(3));

                rafId = requestAnimationFrame(updateVars);
            }

            function onMouseMove(e){
                const rect = block.getBoundingClientRect();
                const px = (e.clientX - rect.left) / rect.width; // 0..1
                const py = (e.clientY - rect.top) / rect.height; // 0..1

                // gentler map to range: -4px .. 4px for x, -3px .. 3px for y, scale 1..1.0125
                targetX = (px - 0.5) * 8; 
                targetY = (py - 0.5) * 6;
                targetS = 1 + Math.max(0, 0.0125 * (1 - Math.abs(px - 0.5) * 2));

                if (!rafId) updateVars();
            }

            function resetParallax(){
                targetX = 0; targetY = 0; targetS = 1;
                // ensure one last frame to snap back
                if (!rafId) updateVars();
                // cancel after a short delay to avoid keeping RAF running
                setTimeout(() => { if (rafId) { cancelAnimationFrame(rafId); rafId = null; } }, 120);
            }

            block.addEventListener('mousemove', onMouseMove);
            block.addEventListener('mouseenter', (e) => { onMouseMove(e); });
            block.addEventListener('mouseleave', resetParallax);
            block.addEventListener('blur', resetParallax);
        });
    })();

    // Parallax effect - background follows cursor (subtle) to match other pages
    (function setupParallax(){
        const bg = document.getElementById('background-video');
        if (!bg) return;
        const maxOffset = 6; // pixels of maximum translation
        const update = (e) => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const offsetX = (e.clientX - w/2) / (w/2);
            const offsetY = (e.clientY - h/2) / (h/2);
            const translateX = offsetX * maxOffset;
            const translateY = offsetY * maxOffset;
            bg.style.transform = `translate(${translateX}px, ${translateY}px)`;
        };
        document.addEventListener('mousemove', update);
    })();

    // Ensure navigation uses sliding closing panels (left/right) like About/Internship pages
    (function setupClosingPanels(){
        // Closing outro disabled on homepage — no-op.
    })();
</script>
</html>
