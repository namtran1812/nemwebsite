<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Deployed fix: remove redirect; timestamp: 2026-01-21T15:33:00Z -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home - Nems Website</title>
    <!-- Resource hints: speed up font loading -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Ballet&display=swap" rel="stylesheet">
    <!-- Preload poster for faster Largest Contentful Paint (LCP) -->
    <link rel="preload" as="image" href="/images/homeimages/homebackground-poster.jpg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100%;
            min-height: 100vh;
            /* make background transparent so video shows through; remove hard black background */
            background-color: transparent;
            background-size: cover;
            background-position: center bottom;
            background-repeat: no-repeat;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            font-family: Arial, sans-serif;
            padding-top: 0;
            position: relative;
            overflow: hidden;
        }

        /* Use the same custom 'bub' cursor as other pages */
        body { cursor: url('images/homeimages/cursor.png') 42 42, pointer; }
        * { cursor: url('images/homeimages/cursor.png') 42 42, pointer !important; }

        /* Remove the solid black curtain so the background video/content is visible
           If you want a dimmer overlay, we can replace this with a semi-transparent gradient. */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
            z-index: -1;
        }

        /* Background video expands off-screen to avoid revealing gaps during small transforms/parallax */
        video#background-video {
            position: fixed;
            top: -6vh;
            left: -60px;
            right: -60px;
            bottom: -6vh;
            width: auto;
            height: auto;
            min-width: calc(100% + 120px);
            min-height: calc(100vh + 12vh);
            object-fit: cover;
            z-index: -1;
            /* Keep the background video sharp (no blur) while optionally starting in grayscale */
            filter: grayscale(100%);
            transition: opacity 520ms ease-in-out, filter 0.6s ease-in-out, transform 0.2s ease;
            transform: translate(0,0);
        }

        video#background-video.color-mode {
            /* When toggled to color-mode, remove grayscale but keep video sharp */
            filter: grayscale(0%);
        }

        /* cinematic blur intro/outro similar to About/Internship pages */
        @keyframes blurToClean {
            0% { filter: blur(15px); }
            100% { filter: blur(0px); }
        }

        @keyframes closingBlur {
            0% { filter: blur(0px); }
            100% { filter: blur(15px); }
        }

    /* Opening blur animation removed for instant load */

        #video-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
            z-index: -1;
            pointer-events: none;
        }

        /* Movie intro effect */
        :root {
            --bar-slide-duration: 1.2s;
            --bar-slide-ease: ease-in-out;
            --bar-overhang: 60px;
            --bar-width: 150px;
            /* duration for the center icon slide; tweak this to slow/speed the slide */
            --center-slide-duration: 2.4s;
            --bar-total: calc(var(--bar-width) + var(--bar-overhang));
        }
        .movie-intro-overlay {
            position: fixed;
            /* expand off-screen to match the persistent bars and avoid visible gaps */
            top: -6vh;
            left: 0;
            width: 100%;
            height: calc(100vh + 12vh);
            background-color: #000;
            z-index: 9999;
            animation: movieIntroOpen 2.5s ease-in-out forwards;
            pointer-events: none;
        }

        .movie-intro-left, .movie-intro-right {
            position: fixed;
            top: -6vh;
            height: calc(100vh + 12vh);
                /* panels are solid black (no opacity, no gradient) for a dense cinematic look */
                background: #000;
                /* place panels behind the intro text overlay so the name/code remains on top while they split */
                z-index: 900;
            pointer-events: none;
            /* smooth transform timing similar to other pages */
            transition: transform var(--bar-slide-duration) var(--bar-slide-ease);
        }

        /* horizontal overhang matches other pages' bar offsets */
        /* Panels are idle by default; applying the .open class runs the openLeft/openRight keyframes */
        .movie-intro-left { left: calc(-1 * var(--bar-overhang)); width: calc(50% + var(--bar-overhang)); }
        .movie-intro-right{ right: calc(-1 * var(--bar-overhang)); width: calc(50% + var(--bar-overhang)); }
        .movie-intro-left.open { animation: openLeft 2.5s ease-in-out forwards; }
        .movie-intro-right.open { animation: openRight 2.5s ease-in-out forwards; }

        @keyframes movieIntroOpen {
            0% {
                opacity: 1;
                clip-path: inset(0);
            }
            100% {
                opacity: 0;
                clip-path: inset(0 0 0 0);
            }
        }

        @keyframes openLeft {
            0% { transform: translateX(0); opacity: 1; }
            /* move fully past the viewport plus horizontal overhang */
            100% { transform: translateX(calc(-100vw - var(--bar-overhang))); opacity: 1; }
        }

        @keyframes openRight {
            0% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(calc(100vw + var(--bar-overhang))); opacity: 1; }
        }

        @keyframes closeLeft {
            0% { transform: translateX(calc(-100vw - var(--bar-overhang))); }
            100% { transform: translateX(0); }
        }

        @keyframes closeRight {
            0% { transform: translateX(calc(100vw + var(--bar-overhang))); }
            100% { transform: translateX(0); }
        }

        .container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 8vh;
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Vertical frame borders (expanded vertically to cover film-style overhangs) */
        .container::before,
        .container::after {
            content: '';
            position: fixed;
            /* expand off-screen vertically to match movie intro panels */
            top: -6vh;
            /* base visible width for the bar (inner edge stays aligned), we'll add an outer overhang */
            width: calc(150px + 60px);
            height: calc(100vh + 12vh);
            background-color: #000;
            z-index: 100;
            transition: width 0.6s ease-in-out, left 0.6s ease-in-out, right 0.6s ease-in-out;
        }

        /* Left bar: keep inner edge where it was, but shift the element left so the outer edge overhangs the viewport */
        .container::before {
            left: -60px; /* outer overhang */
        }

        /* Right bar: mirror the left bar so only the outer (right) edge overhangs */
        .container::after {
            right: -60px; /* outer overhang */
        }

        .container.color-mode::before,
        .container.color-mode::after {
            width: 0px;
        }

        .center-icon {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 40px;
        }

        .center-icon img {
            max-width: 75vw;
            max-height: 75vh;
            width: auto;
            height: auto;
            object-fit: contain;
            z-index: 20;
            transition: opacity 0.3s ease-in-out;
        }

        /* When intro is running, make the center icon non-interactive until intro completes */
        .center-icon.no-interact {
            pointer-events: none;
            cursor: default;
        }

        .content-container {
            position: absolute;
            left: 349px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 25;
            pointer-events: auto;
        }

        .bubble-text {
            position: relative;
            left: 0;
            top: 0;
            transform: none;
            background-color: transparent;
            border: none;
            padding: 15px 30px 25px 50px;
            font-size: 10px;
            font-weight: bold;
            color: white;
            /* preserve line breaks so typed \n becomes a visible new line */
            white-space: pre-wrap;
            max-width: 365px;
            text-align: left;
            font-family: 'Press Start 2P', cursive;
            line-height: 1.428;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 133px;
            width: 343px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 40px rgba(255, 255, 255, 0.6);
        }

        .bubble-text.hidden {
            display: none;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .social-links {
            position: relative;
            left: 0;
            top: -30px;
            transform: none;
            display: flex;
            flex-direction: row;
            gap: 20px;
            z-index: 25;
            padding-left: 50px;
            opacity: 0;
            pointer-events: none;
            align-items: center;
        }

        .social-links.visible {
            opacity: 1;
            pointer-events: auto;
            animation: fadeIn 0.6s ease-in forwards;
        }

        .social-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 34.8px;
            height: 34.8px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            text-decoration: none;
            cursor: pointer;
            transition: transform 0.2s ease;
            filter: brightness(0) invert(1) drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
        }

        .social-icon:hover {
            transform: scale(1.15);
        }

        .email-icon {
            background-image: url('images/homeimages/gmail.png');
        }

        .linkedin-icon {
            background-image: url('images/homeimages/linkedin.png');
        }

        .github-icon {
            background-image: url('images/homeimages/github.png');
        }

        .resume-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 8px 16px;
            background-color: transparent;
            border: 2px solid white;
            border-radius: 20px;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 10px;
            font-weight: bold;
            color: white;
            font-family: 'Press Start 2P', cursive;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        .resume-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
        }

        /* audio control UI removed - audio elements remain for passive playback */

        .avatar-normal {
            cursor: pointer;
            animation: normalBlink 2.8s infinite, float 3s ease-in-out infinite;
            animation-delay: 0s, 0s;
            z-index: 50;
            filter: drop-shadow(0 0 80px rgba(255, 255, 255, 0.8)) grayscale(100%);
        }

        .avatar-closed {
            position: absolute;
            max-width: 75vw;
            max-height: 75vh;
            width: auto;
            height: auto;
            object-fit: contain;
            z-index: 50;
            cursor: pointer;
            animation: closedBlink 2.8s infinite, float 3s ease-in-out infinite;
            animation-delay: 0s, 0s;
            filter: drop-shadow(0 0 80px rgba(255, 255, 255, 0.8)) grayscale(100%);
        }

        .avatar-smile {
            max-width: 75vw;
            max-height: 75vh;
            width: auto;
            height: auto;
            object-fit: contain;
            z-index: 50;
            cursor: pointer;
            display: none;
            animation: smileBlink 2.8s infinite, float 3s ease-in-out infinite;
            animation-delay: 0s, 0s;
            filter: drop-shadow(0 0 80px rgba(255, 255, 255, 0.8));
        }

        .avatar-smile-closed {
            position: absolute;
            max-width: 75vw;
            max-height: 75vh;
            width: auto;
            height: auto;
            object-fit: contain;
            z-index: 50;
            cursor: pointer;
            display: none;
            animation: smileClosedBlink 2.8s infinite, float 3s ease-in-out infinite;
            animation-delay: 0s, 0s;
            filter: drop-shadow(0 0 80px rgba(255, 255, 255, 0.8));
        }

        .avatar-smile.visible {
            display: block;
        }

        .avatar-smile-closed.visible {
            display: block;
        }

        /* Remove glow/drop-shadow on avatars when they become visible or are transitioning */
        .avatar-normal.transitioning,
        .avatar-closed.transitioning,
        .avatar-smile.transitioning,
        .avatar-smile-closed.transitioning,
        .avatar-smile.visible,
        .avatar-smile-closed.visible {
            filter: none !important;
            box-shadow: none !important;
        }

        /* Ensure avatars in the black-and-white (non-color) state do not show glow/drop-shadow.
           The site toggles `.color-mode` on `.container` when switching to color. When not in
           color-mode, force avatars to be strictly grayscale with no drop-shadows. */
        .container:not(.color-mode) .avatar-normal,
        .container:not(.color-mode) .avatar-closed,
        .container:not(.color-mode) .avatar-normal img,
        .container:not(.color-mode) .avatar-closed img {
            /* keep grayscale but remove any drop-shadow/glow */
            filter: grayscale(100%) !important;
            -webkit-filter: grayscale(100%) !important;
            box-shadow: none !important;
        }

        .avatar-normal.hidden {
            display: none;
        }

        .avatar-closed.hidden {
            display: none;
        }

        @keyframes normalBlink {
            0% { opacity: 1; }
            71.43% { opacity: 1; }
            71.5% { opacity: 0; }
            100% { opacity: 0; }
        }

        @keyframes closedBlink {
            0% { opacity: 0; }
            71.43% { opacity: 0; }
            71.5% { opacity: 1; }
            100% { opacity: 1; }
        }

        @keyframes smileBlink {
            0% { opacity: 1; }
            71.43% { opacity: 1; }
            71.5% { opacity: 0; }
            100% { opacity: 0; }
        }

        @keyframes smileClosedBlink {
            0% { opacity: 0; }
            71.43% { opacity: 0; }
            71.5% { opacity: 1; }
            100% { opacity: 1; }
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-5px);
            }
        }

        @keyframes slideCloudOutPart1 {
            from {
                transform: translate(calc(-50% + 100vw), -50%);
            }
            to {
                transform: translate(-30%, -50%);
            }
        }

        @keyframes slideCloudOutPart2 {
            from {
                transform: translate(-30%, -50%);
            }
            to {
                transform: translate(-150%, -50%);
            }
        }



        @keyframes glow {
            0% {
                filter: drop-shadow(0 0 0px rgba(231, 143, 165, 0));
            }
            50% {
                filter: drop-shadow(0 0 15px rgba(231, 143, 165, 1)) drop-shadow(0 0 25px rgba(231, 143, 165, 0.8));
            }
            100% {
                filter: drop-shadow(0 0 0px rgba(231, 143, 165, 0));
            }
        }

        @keyframes colorBlend {
            0% {
                filter: drop-shadow(0 0 80px rgba(255, 255, 255, 0.8)) grayscale(100%);
            }
            100% {
                filter: drop-shadow(0 0 80px rgba(255, 255, 255, 0.8)) grayscale(0%);
            }
        }

        .avatar-normal.transitioning,
        .avatar-closed.transitioning {
            animation: colorBlend 0.6s ease-in-out forwards !important;
        }

        .avatar-smile.transitioning,
        .avatar-smile-closed.transitioning {
            animation: colorBlend 0.6s ease-in-out forwards !important;
        }

        @keyframes fadeInScale {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes fadeOutScale {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0);
            }
        }

        .lotus-block {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0;
            z-index: 10;
            margin: 0;
            margin-top: -1px;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .block-container {
            position: absolute;
            width: 600px;
            height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0;
            opacity: 0;
            transform: scale(0);
            z-index: 30;
            animation: float 3s ease-in-out infinite;
            animation-delay: 0s;
            cursor: pointer;
            transition: transform 0.2s ease;
            pointer-events: none;
        }

        .block-container.visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
            animation: fadeInScale 0.6s ease-in-out forwards, float 3s ease-in-out infinite !important;
            animation-delay: 0s, 0.6s;
            /* subtle pink glow when blocks are visible by default */
            filter: drop-shadow(0 0 15px rgba(231, 143, 165, 0.9)) drop-shadow(0 0 25px rgba(231, 143, 165, 0.6)) !important;
        }

        /* Apply glow directly on the lotus image for stronger visual presence */
        .block-container.visible .small-lotus {
            filter: drop-shadow(0 0 15px rgba(231, 143, 165, 0.9)) drop-shadow(0 0 25px rgba(231, 143, 165, 0.6)) !important;
        }

        .block-container.fading-out {
            animation: fadeOutScale 0.6s ease-in-out forwards !important;
        }

        /* Disabled glow: remove animated glow when clicking blocks. */
        .block-container.glowing {
            /* explicitly disable the glow animation */
            animation: none !important;
            /* ensure no drop-shadow is applied */
            filter: none !important;
        }

        .small-lotus {
            position: relative;
            width: 50px;
            height: 50px;
            background-image: url('images/homeimages/smalllotus.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            flex-shrink: 0;
        }

        .head-lotus {
            position: absolute;
            width: 50px;
            height: 50px;
            background-image: url('images/homeimages/smalllotus.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            transform: scale(0);
            z-index: 5;
            animation: float 3s ease-in-out infinite;
            animation-delay: 0s;
            display: none;
        }

        .block-container.visible ~ .head-lotus {
            opacity: 1;
            transform: scale(1);
            display: none;
        }

        .head-lotus-left {
            top: -5%;
            left: 10%;
            transform: rotate(-45deg);
        }

        .head-lotus-right {
            top: -5%;
            right: 10%;
            transform: rotate(45deg);
        }

        .head-lotus-middle-left {
            top: 45%;
            left: 5%;
            transform: rotate(-90deg);
        }

        .head-lotus-middle-right {
            top: 45%;
            right: 5%;
            transform: rotate(90deg);
        }

        .head-lotus-bottom-left {
            bottom: 25%;
            left: 5%;
            transform: rotate(-135deg);
        }

        .head-lotus-bottom-right {
            bottom: 25%;
            right: 5%;
            transform: rotate(135deg);
        }

        .head-lotus-between-1-2 {
            top: 29%;
            left: 20%;
            transform: rotate(-90deg);
        }

        .head-lotus-between-4-5 {
            top: 29%;
            right: 20%;
            transform: rotate(90deg);
        }

        .lotus-label {
            /* match bubble text size and visual weight to be consistent */
            font-size: 10px;
            font-weight: bold;
            color: #E78FA5;
            text-align: left;
            white-space: nowrap;
            pointer-events: none;
            font-family: 'Press Start 2P', cursive;
            z-index: 20;
            position: relative;
            letter-spacing: 0.5px;
            line-height: 1.3;
        }

        /* New grid for page previews */
        /* Use fixed positioning so we can place the grid using viewport coordinates
           (the previous absolute positioning was relative to .center-icon and could
           place the grid off-screen when JS used getBoundingClientRect() values).
        */
        .page-grid {
            position: fixed;
            /* place the grid to the right of the center icon; use left so it won't clip on small screens */
            /* default closer to center so it's visually near the avatar on many viewports */
            left: calc(50% + 0px);
            /* move the grid up by 15% of viewport height (5% more than before) */
            top: calc(12vh - 15vh);
            width: min(44vw, 740px);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-auto-rows: 1fr;
            gap: 20px;
            opacity: 0;
            transform: translateX(8px) scale(0.99);
            transition: opacity 300ms ease, transform 350ms cubic-bezier(.2,.9,.2,1);
            pointer-events: none;
            z-index: 99999;
        }

        /* Header above the grid */
        .grid-header {
            grid-column: 1 / -1;
            font-family: 'Ballet', 'Brush Script MT', 'Lucida Handwriting', cursive;
            font-size: clamp(28px, 4.2vw, 56px);
            color: #ffffff;
            text-align: center;
            padding: 0;
            margin: 0 0 12px 0;
            letter-spacing: 0.6px;
            text-shadow: 0 3px 12px rgba(0,0,0,0.6);
            align-self: center;
            justify-self: center;
            z-index: 100000;
        }

        .page-grid.visible {
            opacity: 1;
            transform: none;
            pointer-events: auto;
        }

        .center-icon {
            /* use CSS variable so JS can read and keep timeouts in sync */
            transition: transform var(--center-slide-duration, 420ms) cubic-bezier(.2,.9,.2,1);
            will-change: transform;
            /* start below the intro overlay so closed BW avatar is hidden behind intro panels/texts */
            position: relative;
            z-index: 800;
        }

        /* promoted state after intro completes */
        .center-icon.icon-top {
            z-index: 11000; /* keep icon above the crossfade overlay and other UI */
        }

        .center-icon img {
            transition: none;
        }

        .center-icon.grid-open img {
            opacity: 1;
            filter: none;
            transform: none;
        }

        /* Both smile avatars should be display:block for blinking in smile state */
        .center-icon .avatar-smile.visible,
        .center-icon .avatar-smile-closed.visible {
            display: block !important;
        }

        /* Subtle slide of the whole center icon so the movement is visible across browsers
           and doesn't get clipped when descendants are hidden. Use a smaller translation
           so the change is noticeable but not drastic. */
        .center-icon.slide-left {
            transform: translateX(-20vw);
        }

        /* Remove the image-level translation; animating the container is more reliable. */
        .center-icon.slide-left img {
            transform: none;
            transition: none;
        }

        /* hide existing lotus blocks when grid is active to avoid overlap */
        .center-icon.slide-left .block-container { display: none !important; }

        /* Glassmorphism card for each page block */
        .grid-block {
            position: relative;
            width: 100%;
            aspect-ratio: 4 / 3;
            border-radius: 14px;
            overflow: hidden;
            cursor: pointer;
            display: flex;
            align-items: stretch;
            justify-content: stretch;
                /* Solid black matte tint with tiled grain texture (applied as background image)
                    to match the About page aesthetic. Keep a subtle border and shadow. */
                background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='1.2' numOctaves='3' stitchTiles='stitch'/><feColorMatrix type='matrix' values='0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 0.3'/></filter><rect width='100%' height='100%' fill='black' filter='url(%23n)'/></svg>");
                background-repeat: repeat;
                background-size: 120px 120px;
                background-color: rgba(0,0,0,0.6);
                background-blend-mode: multiply;
                border: 1px solid rgba(255,255,255,0.10);
                /* reduce heavy backdrop blur on homepage blocks to avoid overly soft backgrounds */
                -webkit-backdrop-filter: none;
                backdrop-filter: none;
                box-shadow: 0 12px 30px rgba(0,0,0,0.55), inset 0 1px 0 rgba(255,255,255,0.03);
            transition: transform 480ms cubic-bezier(.22,.8,.28,1), box-shadow 480ms cubic-bezier(.22,.8,.28,1), border-color 420ms ease;
            outline: none;
        }

        /* Sheen and subtle noise to enhance the glass 'material' */
        .grid-block::before {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.02) 25%, rgba(255,255,255,0.00) 50%);
            mix-blend-mode: overlay;
            transform: translateY(-12%);
            filter: blur(6px);
            opacity: 0.95;
        }

        /* The grain is applied as the background image on .grid-block so it covers the full area */

        /* When the grid is open, hide the avatar images so the grid is visible */
        .center-icon.grid-open .avatar-normal,
        .center-icon.grid-open .avatar-closed,
        .center-icon.grid-open .avatar-smile,
        .center-icon.grid-open .avatar-smile-closed {
            opacity: 0;
            pointer-events: none;
            transition: opacity 280ms ease;
        }

        .grid-block:focus { box-shadow: 0 0 0 3px rgba(231,143,165,0.8); }

    .grid-block .block-inner { position: relative; width: 100%; height: 100%; }
        .grid-block .thumb-wrapper { border-radius: 12px; overflow: hidden; }
        .grid-block img.static-thumb {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            filter: grayscale(100%) blur(2px) contrast(95%) brightness(85%);
            /* use CSS variables so JS can nudge the image for parallax */
            --px: 0px;
            --py: 0px;
            --ps: 1;
            transform: translate3d(var(--px), var(--py), 0) scale(var(--ps));
            transition: filter 420ms cubic-bezier(.22,.8,.28,1), transform 420ms cubic-bezier(.22,.8,.28,1);
            transform-origin: center center;
        }

        .grid-block:hover img.static-thumb,
        .grid-block:focus img.static-thumb,
        .grid-block.active img.static-thumb,
        .grid-block.revealed:hover img.static-thumb {
            filter: none;
            transform: translate3d(var(--px), var(--py), 0) scale(var(--ps));
        }

        /* Thumbnail iframe that renders the dedicated page scaled down.
           Default is grayscale and slightly dimmed; on hover/focus it becomes colored.
        */
        .grid-block .thumb-wrapper { position: absolute; inset: 0; width: 100%; height: 100%; overflow: hidden; }
        .grid-block iframe.thumb {
            position: absolute;
            top: 0; left: 0;
            /* Scale down the full page to a thumbnail. width/height are inverse of scale. */
            width: 400%;
            height: 400%;
            transform: scale(0.25);
            transform-origin: top left;
            border: none;
            display: block;
            pointer-events: none; /* prevent interaction in thumbnail state */
            filter: grayscale(100%) contrast(95%) brightness(85%);
            transition: filter 320ms ease, opacity 200ms ease, transform 320ms ease;
        }

        .grid-block video.preview {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transition: opacity 300ms ease;
            pointer-events: none;
        }

        /* Stagger reveal defaults for header and blocks */
    .grid-header { opacity: 0; transform: translateY(4px); }
    .grid-header.revealed { opacity: 1; transform: none; transition: opacity 520ms cubic-bezier(.22,.8,.28,1), transform 520ms cubic-bezier(.22,.8,.28,1); }

    .grid-block { opacity: 0; transform: translateY(6px) scale(0.992); }
    .grid-block.revealed { opacity: 1; transform: none; transition: opacity 520ms cubic-bezier(.22,.8,.28,1), transform 520ms cubic-bezier(.22,.8,.28,1); }

    /* Fade-out helper for the grid header and blocks when closing the grid */
    .grid-header.fading-out { opacity: 0; transform: translateY(6px); transition: opacity 100ms linear, transform 100ms linear; }
    .grid-block.fading-out { opacity: 0; transform: translateY(6px) scale(0.992); transition: opacity 100ms linear, transform 100ms linear; }

        .grid-block .block-title {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-family: 'Press Start 2P', monospace;
            font-weight: 400;
            text-shadow: 0 4px 18px rgba(0,0,0,0.65);
            font-size: 9px;
            z-index: 6;
            text-align: center;
            padding: 8px 16px;
            /* Make the title background transparent by default so it doesn't obscure the thumbnail */
            background: transparent;
            /* allow smooth fade when the parent block is hovered/focused */
            transition: opacity 320ms cubic-bezier(.22,.8,.28,1);
            border-radius: 6px;
            /* Pixelated look */
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: grayscale;
            image-rendering: pixelated;
            transform-style: preserve-3d;
        }

        /* Keep "Chapter N:" on a single row and subtitle on the next line */
        .grid-block .block-title .block-chapter {
            display: inline-block;
            white-space: nowrap;
            margin-right: 6px;
            /* nudge chapter slightly left to create separation from subtitle */
            transform: translateX(-8px);
            transition: transform 220ms ease;
        }

        .grid-block .block-title .block-subtitle {
            display: block;
            margin-top: 6px;
            font-family: 'Ballet', serif;
            font-size: 30px;
            line-height: 1.0;
            letter-spacing: 0.2px;
            text-transform: none;
            color: #fff;
            /* nudge subtitle slightly right to balance the shifted chapter */
            transform: translateX(8px);
            transition: transform 220ms ease;
        }

        /* Make Ballet subtitles slightly bolder/stronger for better legibility */
        .grid-block .block-title .block-subtitle {
            font-weight: 600;
            /* remove dark stroke so the font appears pure white; use a very subtle light highlight + soft shadow */
            -webkit-text-stroke: 0px rgba(0,0,0,0);
            text-shadow: 0 1px 0 rgba(255,255,255,0.06), 0 2px 6px rgba(0,0,0,0.09);
        }

        /* Ballet font helper for the About subtitle */
        .ballet {
            font-family: 'Ballet', serif;
            font-style: normal;
            font-weight: 400;
            font-size: 12px;
            line-height: 1.1;
            letter-spacing: 0.6px;
            text-transform: none;
        }

        /* Fade the title out when the block is hovered, focused, or active */
        .grid-block:hover .block-title,
        .grid-block:focus .block-title,
        .grid-block.active .block-title {
            opacity: 0;
        }

        /* Hover/focus active state: show preview video and remove grayscale */
        .grid-block.active iframe.thumb,
        .grid-block:hover iframe.thumb,
        .grid-block:focus iframe.thumb {
            filter: none;
            transform: scale(0.25);
        }

        /* Hover / focus - lift and glow */
        .grid-block:hover,
        .grid-block:focus,
        .grid-block.revealed:hover {
            transform: translateY(-6px) scale(1.01);
            box-shadow: 0 18px 40px rgba(0,0,0,0.55), 0 6px 30px rgba(231,143,165,0.08);
            border-color: rgba(231,143,165,0.28);
        }

    /* Intro overlay styles */
    /* Start the overlay below the movie panels so the panels can split open first */
    #intro-overlay {
        position: fixed;
        inset: 0;
        /* make overlay background transparent so the underlying video/content is visible */
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000; /* start below the movie panels */
        pointer-events: none;
    }

    /* When movie panels are done, promote overlay to top of UI */
    .intro-overlay-top { z-index: 2147483646 !important; }

    /* Ensure the center icon (closed BW avatar) is behind the intro overlay/panels while
       the overlay is active and not yet promoted. This prevents the avatar from appearing
       in front of the bars/text during the intro. */
    #intro-overlay:not(.intro-overlay-top) ~ .container .center-icon,
    #intro-overlay:not(.intro-overlay-top) ~ .container .center-icon * {
        z-index: 100 !important;
    }

    #intro-overlay .intro-center { text-align: center; }
    .intro-name {
        font-family: 'Ballet', 'Brush Script MT', cursive;
        color: white;
        font-size: clamp(28px, 8vw, 120px);
        letter-spacing: 1px;
        display: inline-block;
        -webkit-font-smoothing: antialiased;
        /* subtle glow to match the site's pink accent */
        text-shadow: 0 8px 22px rgba(231,143,165,0.28), 0 0 10px rgba(231,143,165,0.18);
    }

    /* Individual parts start blurred and slightly transparent */
    .intro-name .intro-first,
    .intro-name .intro-last {
        display: inline-block;
        opacity: 0.08;
        filter: blur(4px) brightness(0.6);
        transform: translateY(4px) scale(0.995);
        transition: opacity 1200ms ease, filter 1200ms ease, transform 1200ms ease;
    }

    /* Reveal the first name then the last name */
    .intro-name.reveal-first .intro-first { opacity: 1; filter: none; transform: none; }
    .intro-name.reveal-last .intro-last { opacity: 1; filter: none; transform: none; }

    /* During fade/blur stage (when removing intro), fade entire overlay more slowly */
    /* Increased to 1800ms for a longer, smoother blur-out */
    #intro-overlay.intro-fade { opacity: 0; transition: opacity 1800ms linear; }

    /* When the overlay is fading, blur the name and code lines for a smoother transition into the homepage */
    #intro-overlay.intro-fade .intro-name,
    #intro-overlay.intro-fade .intro-code {
        filter: blur(6px) brightness(0.6);
        opacity: 0;
        transform: translateY(-8px) scale(0.995);
        transition: filter 1800ms ease, opacity 1800ms ease, transform 1800ms ease;
    }

    /* Intro code line (pixelated) under the name */
    .intro-code {
        margin-top: 12px;
        color: #e8e8e8;
        font-family: 'Press Start 2P', monospace;
        font-size: clamp(9px, 1.6vw, 12px);
        letter-spacing: 0.4px;
        display: block; /* ensure it sits on its own line under the name */
        width: 100%;
        text-align: center;
        opacity: 0.08; /* start faded like the name parts */
        filter: blur(4px) brightness(0.6);
        transform: translateZ(0) translateY(4px) scale(0.995);
        transition: opacity 1200ms ease, filter 1200ms ease, transform 1200ms ease;
        -webkit-font-smoothing: none;
        -moz-osx-font-smoothing: grayscale;
        image-rendering: pixelated;
        /* nudge the printed line upward by 5% of the viewport for visual spacing */
        margin-top: 6px;
        /* light pixelated glow for the code line */
        text-shadow: 0 6px 16px rgba(231,143,165,0.18), 0 0 6px rgba(231,143,165,0.12);
    }

    .intro-code.reveal {
        opacity: 1;
        filter: none;
        transform: translateZ(0) translateY(-5vh) scale(1);
    }

    .intro-code .code-text { white-space: pre; }
    /* styled parts for the printed line so 'print(' can be smaller */
    /* Keep all code parts the same base font-size so 'print(' looks consistent */
    .intro-code .code-prefix { font-size: 1em; opacity: 0.95; color: #dcdcdc; }
    .intro-code .code-inner { font-size: 1em; color: #ffffff; }
    .intro-code .code-quote { color: #cfcfcf; }
    .intro-code .code-suffix { font-size: 1em; color: #dcdcdc; }


        .grid-block:focus { box-shadow: 0 0 0 3px rgba(231,143,165,0.12); }

        .grid-block.active video.preview,
        .grid-block:hover video.preview,
        .grid-block:focus video.preview {
            opacity: 1;
        }

    /* Visual adjustments: remove debug outlines; keep focus outline on grid-block for accessibility */
    .page-grid { outline: none; }
    .grid-block { outline: none; }

        /* lotus labels will use the same typing timing as the bubble text (handled in JS) */

        /* Hover effect: highlight the label when mouse is over the lotus block or visible block-container */
        .block-container.visible:hover .lotus-label,
        .block-container.visible .lotus-block:hover .lotus-label {
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255,255,255,0.6);
            transform: translateY(-2px);
            transition: color 180ms ease, text-shadow 180ms ease, transform 160ms ease;
        }

        /* Position 6 lotus blocks surrounding the avatar */
        .block-1 {
            top: -5%;
            left: -80%;
        }

        .block-2 {
            top: 30%;
            left: -80%;
        }

        .block-3 {
            top: 65%;
            left: -80%;
        }

        .block-4 {
            top: -5%;
            right: -80%;
        }

        .block-5 {
            top: 30%;
            right: -80%;
        }

        .block-6 {
            top: 65%;
            right: -80%;
        }

        .block-1 .lotus-block,
        .block-2 .lotus-block,
        .block-3 .lotus-block {
            flex-direction: row;
        }

        .block-4 .lotus-block,
        .block-5 .lotus-block,
        .block-6 .lotus-block {
            flex-direction: row-reverse;
        }

        @media (max-width: 768px) {
            .center-icon img {
                max-width: 75vw;
                max-height: 75vh;
            }

            .small-lotus {
                width: 60px;
                height: 60px;
            }
        }
    </style>
</head>
<body>
    <!-- Movie Intro Overlay -->
    <div class="movie-intro-left" id="movieIntroLeft"></div>
    <div class="movie-intro-right" id="movieIntroRight"></div>

    <!-- Background video: lazy-load sources after first paint to improve initial load -->
    <video id="background-video" muted loop playsinline poster="images/homeimages/homebackground-poster.jpg">
        <!-- sources appended by JS to avoid blocking initial render -->
        Your browser does not support the video tag.
    </video>
    <!-- Persistent cross-fade overlay used during navigation to avoid video pop/flash -->
    <div id="crossfade-overlay" style="position:fixed;inset:0;background:#000;opacity:0;pointer-events:none;transition:opacity 420ms ease-in-out;z-index:1000"></div>
    <audio id="background-music" loop>
        <source src="images/homeimages/background-music.mp3" type="audio/mpeg">
        Your browser does not support the audio tag.
    </audio>
    <audio id="smile-music" loop>
        <source src="images/homeimages/smile-music.mp3" type="audio/mpeg">
        Your browser does not support the audio tag.
    </audio>
    <div id="video-overlay"></div>
    <div class="container">
        <div class="center-icon">
            <div class="block-container block-1">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="About Me">About Me</div>
                </div>
            </div>
            
            <div class="block-container block-2">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="Internship">Internship</div>
                </div>
            </div>
            
            <div class="block-container block-3">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="Leadership">Leadership</div>
                </div>
            </div>
            
            <div class="block-container block-4">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="Technical">Technical</div>
                </div>
            </div>
            
            <div class="block-container block-5">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="Creative">Creative</div>
                </div>
            </div>
            
            <div class="block-container block-6">
                <div class="lotus-block">
                    <div class="lotus-label" data-full-text="Questions">Questions</div>
                </div>
            </div>

            <!-- Lotuses around avatar head -->
            <div class="head-lotus head-lotus-left"></div>
            <div class="head-lotus head-lotus-right"></div>
            <div class="head-lotus head-lotus-middle-left"></div>
            <div class="head-lotus head-lotus-middle-right"></div>
            <div class="head-lotus head-lotus-bottom-left"></div>
            <div class="head-lotus head-lotus-bottom-right"></div>
            <div class="head-lotus head-lotus-between-1-2"></div>
            <div class="head-lotus head-lotus-between-4-5"></div>
            
            <img class="avatar-normal" src="images/homeimages/fullbodyiconclosed-transparent.png" alt="Nems Character">
            <img class="avatar-closed" src="images/homeimages/fullbodyiconclosed-transparent.png" alt="Nems Character Closed">
            <img class="avatar-smile hidden" src="images/homeimages/fullbodyiconsmile-transparent.png" alt="Nems Character Smile">
            <img class="avatar-smile-closed hidden" src="images/homeimages/fullbodyiconsmileclosed-transparent.png" alt="Nems Character Smile Closed">
            
            <div class="content-container">
                <div class="bubble-text" id="bubble-text"></div>
                
                <div class="social-links">
                    <a href="mailto:trannam18122005@gmail.com" class="social-icon email-icon" title="Email">
                    </a>
                    <a href="https://www.linkedin.com/in/nam2k5/" target="_blank" class="social-icon linkedin-icon" title="LinkedIn">
                    </a>
                    <a href="https://github.com/namtran1812" target="_blank" class="social-icon github-icon" title="GitHub">
                    </a>
                    <a href="https://drive.google.com/file/d/1uaXQkaI4neAuVnUcJ4sV0PwdZeFPL7Jn/view?usp=sharing" target="_blank" class="resume-button" title="Resume">
                        Resume
                    </a>
                </div>
            </div>
            <!-- Two-row 3-column grid revealed when avatar is clicked -->
            <div class="page-grid" id="pageGrid" aria-hidden="true">
                <div class="grid-header">choose your chapter</div>
                <!-- Each block has data-url for navigation, optional data-video for hover preview -->
                <div class="grid-block" data-url="about.html" data-video="images/aboutmeimages/aboutmebackground.mp4" tabindex="0">
                    <div class="block-inner">
                        <div class="thumb-wrapper">
                            <img class="static-thumb" src="images/aboutmeimages/saigon.png" alt="About thumbnail" loading="lazy">
                        </div>
                        <!-- no video preview; static image only -->
                        <div class="block-title"><span class="block-chapter">chapter 1</span> <span class="block-subtitle ballet">about me</span></div>
                    </div>
                </div>
                <div class="grid-block" data-url="internship.html" data-video="images/internshipimages/internshipbackground.mp4" tabindex="0">
                    <div class="block-inner">
                        <div class="thumb-wrapper">
                            <img class="static-thumb" src="images/internshipimages/tech.png" alt="Internship thumbnail" loading="lazy">
                        </div>
                        <!-- no video preview; static image only -->
                        <div class="block-title"><span class="block-chapter">chapter 2</span> <span class="block-subtitle">internship</span></div>
                    </div>
                </div>
                <div class="grid-block" data-url="leadership.html" tabindex="0">
                    <div class="block-inner">
                        <div class="thumb-wrapper">
                            <img class="static-thumb" src="images/leadershipimages/uf.png" alt="Leadership thumbnail" loading="lazy">
                        </div>
                        <div class="block-title"><span class="block-chapter">chapter 3</span> <span class="block-subtitle">leadership</span></div>
                    </div>
                </div>
                <div class="grid-block" data-url="technical.html" tabindex="0">
                    <div class="block-inner">
                        <div class="thumb-wrapper">
                            <img class="static-thumb" src="images/technicalimages/code.png" alt="Technical thumbnail" loading="lazy">
                        </div>
                        <div class="block-title"><span class="block-chapter">chapter 4</span> <span class="block-subtitle">technical</span></div>
                    </div>
                </div>
                <div class="grid-block" data-url="creative.html" tabindex="0">
                    <div class="block-inner">
                        <div class="thumb-wrapper">
                            <img class="static-thumb" src="images/creativeimages/creative.png" alt="Creative thumbnail" loading="lazy">
                        </div>
                        <div class="block-title"><span class="block-chapter">chapter 5</span> <span class="block-subtitle">creative</span></div>
                    </div>
                </div>
                <div class="grid-block" data-url="questions.html" tabindex="0">
                    <div class="block-inner">
                        <div class="thumb-wrapper">
                            <img class="static-thumb" src="images/questionsimages/questions.png" alt="Questions thumbnail" loading="lazy">
                        </div>
                        <div class="block-title"><span class="block-chapter">chapter 6</span> <span class="block-subtitle">questions</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- audio control UI removed from page (volume button hidden) -->
    <!-- Intro overlay: shows the name in Ballet font on black, then blurs/fades to the page -->
    <div id="intro-overlay" aria-hidden="true">
        <div class="intro-center">
            <div class="intro-name"><span class="intro-first">Nam</span> <span class="intro-last">Tran</span></div>
            <!-- Pixelated code line under the name (no caret) -->
            <div class="intro-code" aria-hidden="true">
                <span class="code-text"></span>
            </div>
        </div>
    </div>
</body>
<script>
    // --- Intro code typing helpers ---
    const introTypingTimers = [];
    function clearIntroTypingTimers() {
        while (introTypingTimers.length) {
            const id = introTypingTimers.pop();
            try { clearTimeout(id); } catch(e) {}
        }
    }

    function runIntroCodeSequence(startDelay = 900) {
        const overlay = document.getElementById('intro-overlay');
        if (!overlay) return;
    const codeEl = overlay.querySelector('.intro-code .code-text');
    if (!codeEl) return;

        const prefix = 'print("';
    const innerA = 'xin cho';
        const suffix = '")';
    const innerB = 'hello world';

        const fullA = prefix + innerA + suffix; // print("Xin chao")

        const typeSpeed = 70; // ms per char
        const deleteSpeed = 60;

        // Helper: type a string into codeEl, returns promise-like via timeouts
        function typeString(str, delayBefore = 0, cb) {
            let i = 0;
            const t = setTimeout(function step(){
                if (i < str.length) {
                    codeEl.textContent += str[i++];
                    introTypingTimers.push(setTimeout(step, typeSpeed));
                } else if (typeof cb === 'function') cb();
            }, delayBefore);
            introTypingTimers.push(t);
        }

        // Helper: delete N characters from just before the suffix (keep suffix intact)
        function deleteInner(count, delayBefore = 0, cb) {
            const t = setTimeout(function step(){
                // Ensure suffix stays; if not present, just trim from end
                let txt = codeEl.textContent || '';
                if (txt.endsWith(suffix)) {
                    // remove one char before the suffix
                    if (count > 0) {
                        const withoutSuffix = txt.slice(0, -suffix.length);
                        const newWithout = withoutSuffix.slice(0, -1);
                        codeEl.textContent = newWithout + suffix;
                        count--;
                        introTypingTimers.push(setTimeout(step, deleteSpeed));
                    } else if (typeof cb === 'function') cb();
                } else {
                    // fallback: pop characters from the end
                    if (count > 0 && txt.length > 0) {
                        codeEl.textContent = txt.slice(0, -1);
                        count--;
                        introTypingTimers.push(setTimeout(step, deleteSpeed));
                    } else if (typeof cb === 'function') cb();
                }
            }, delayBefore);
            introTypingTimers.push(t);
        }

        // Start the sequence after a short delay so the name reveal is visible first
        introTypingTimers.push(setTimeout(() => {
            codeEl.textContent = '';
            // Type the whole first variant
            typeString(fullA, 0, () => {
                // small pause, then delete only the inner 'Xin chao'
                introTypingTimers.push(setTimeout(() => {
                    deleteInner(innerA.length, 0, () => {
                        // after deletion, type the new inner text INSIDE the quotes
                        try {
                            codeEl.textContent = prefix; // reset to 'print("'
                        } catch(e) {}
                        typeString(innerB, 120, () => {
                            // append the suffix after the inner text so the final string is print("...")
                            try { codeEl.textContent = (codeEl.textContent || '') + suffix; } catch(e) {}
                            // After a short pause, replace the plain text with styled spans so we can reduce the "print(" font
                            introTypingTimers.push(setTimeout(() => {
                                try {
                                    const esc = (s) => String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                                    const innerEsc = esc(innerB);
                                    codeEl.innerHTML = `<span class="code-prefix">print(</span><span class="code-quote">"</span><span class="code-inner">${innerEsc}</span><span class="code-quote">"</span><span class="code-suffix">)</span>`;
                                } catch(e) { /* ignore */ }
                            }, 500));
                        });
                    });
                }, 700));
            });
        }, startDelay));
    }

    const avatarNormal = document.querySelector('.avatar-normal');
    const avatarClosed = document.querySelector('.avatar-closed');
    const avatarSmile = document.querySelector('.avatar-smile');
    const avatarSmileClosed = document.querySelector('.avatar-smile-closed');
    const blocks = document.querySelectorAll('.block-container');
    const headLotuses = document.querySelectorAll('.head-lotus');
    const bubbleText = document.querySelector('.bubble-text');
    // Ensure bubbleTextElement and socialLinks are available early for showSmile/hideSmile
    // fall back to querySelector if the specific id isn't present yet
    const bubbleTextElement = document.getElementById('bubble-text') || bubbleText;
    const socialLinks = document.querySelector('.social-links') || null;
    let blocksVisible = false;
    const pageGrid = document.getElementById('pageGrid');
    const centerIcon = document.querySelector('.center-icon');

        // early handle for background video
        const backgroundVideo = document.getElementById('background-video');
        // Lazy-load video sources after first paint to avoid blocking initial render
        (function() {
            try {
                if (!backgroundVideo) return;
                window.requestAnimationFrame(() => {
                        const s1 = document.createElement('source');
                        // optimized WebM (720p)
                        s1.src = 'images/homeimages/homebackground-720.webm';
                        s1.type = 'video/webm';
                        const s2 = document.createElement('source');
                        // optimized H.264 MP4 (720p, faststart)
                        s2.src = 'images/homeimages/homebackground-720.mp4';
                        s2.type = 'video/mp4';
                    backgroundVideo.appendChild(s1);
                    backgroundVideo.appendChild(s2);
                    // start loading and attempt autoplay (silent) if allowed
                    backgroundVideo.load();
                    backgroundVideo.play().catch(()=>{});
                });
            } catch(e) { console.debug('video lazy-load error', e); }
        })();

    // Bubble text typing state and helper (restore typing behavior)
    const fullText = "welcome to my world.\nplease click on me to explore more about myself.";
    let currentCharIndex = 0;
    function typeNextCharacter() {
        try {
            if (currentCharIndex < fullText.length) {
                if (bubbleTextElement) bubbleTextElement.textContent += fullText[currentCharIndex];
                currentCharIndex++;
                setTimeout(typeNextCharacter, 50);
            } else {
                // show social links when done if grid not visible
                if (!blocksVisible && socialLinks) socialLinks.classList.add('visible');
            }
        } catch (e) { console.debug('typeNextCharacter error', e); }
    }

    // Social links will be revealed when the bubble typing finishes

    // Navigation mapping
    const blockNavigation = {
        'block-1': 'about.html',
        'block-2': 'internship.html',
        'block-3': 'leadership.html',
        'block-4': 'technical.html',
        'block-5': 'creative.html',
        'block-6': 'questions.html'
    };

    // Add click listeners to blocks for navigation
    document.addEventListener('click', function(e) {
        // Check if the click target is a lotus-label or lotus-block
        let closestLabel = e.target.closest('.lotus-label');
        let closestBlock = e.target.closest('.lotus-block');
        
        if (closestLabel || closestBlock) {
            // Find the parent block-container
            let blockContainer = e.target.closest('.block-container');
            
            if (blockContainer) {
                console.log('Block clicked! blocksVisible:', blocksVisible);
                
                if (blocksVisible) {
                    e.stopPropagation();
                    
                    // Glow effect disabled  no visual glow should appear on click
                    
                    // Get the block class (block-1, block-2, etc., not block-container)
                    let blockClass = null;
                    for (let cls of blockContainer.classList) {
                        if (cls.startsWith('block-') && cls !== 'block-container') {
                            blockClass = cls;
                            break;
                        }
                    }
                    
                    console.log('Block class:', blockClass, 'URL:', blockNavigation[blockClass]);
                    
                    // Navigate after cloud animation (0.2s for part1)
                    // This allows the cloud to transition smoothly to the new page
                    setTimeout(() => {
                        if (blockClass && blockNavigation[blockClass]) {
                            console.log('Navigating to:', blockNavigation[blockClass]);
                            
                            // Fade out music before navigation
                            // Show cross-fade overlay and fade out the homepage background video for a smooth transition
                            try { const overlay = document.getElementById('crossfade-overlay'); if (overlay) overlay.style.opacity = '1'; } catch(e) {}
                            try { if (backgroundVideo) backgroundVideo.style.opacity = '0'; } catch(e) {}
                            const backgroundMusic = document.getElementById('background-music');
                            const smileMusic = document.getElementById('smile-music');
                            const currentAudio = blocksVisible ? smileMusic : backgroundMusic;
                            const fadeOutDuration = 300; // 300ms fade out
                            const fadeOutInterval = 30; // Update every 30ms
                            const steps = fadeOutDuration / fadeOutInterval;
                            let currentStep = 0;
                            const originalVolume = currentAudio.volume;
                            
                            // Fade out current audio
                            const fadeOutTimer = setInterval(() => {
                                currentStep++;
                                const progress = currentStep / steps;
                                currentAudio.volume = originalVolume * (1 - progress);
                                
                                if (progress >= 1) {
                                    clearInterval(fadeOutTimer);
                                    currentAudio.pause();
                                    currentAudio.volume = originalVolume; // Reset for next page
                                    
                                    // Navigate after audio fade completes, but wait until the center icon
                                    // finishes sliding back to its original position so the UX feels synced.
                                    const navigateToRaw = blockNavigation[blockClass];
                                    if (navigateToRaw) {
                                        // append a query param so the destination page can perform a coordinated transition
                                        // Append a cache-busting timestamp so the destination page loads
                                        // a fresh copy instead of a potentially cached one.
                                        const url = navigateToRaw + (navigateToRaw.includes('?') ? '&' : '?') + 'from=home' + '&_=' + Date.now();
                                        navigateAfterSlide(url);
                                    }
                                }
                            }, fadeOutInterval);
                        }
                    }, 300);
                }
            }
        }
    });

    function showSmile() {
        console.log('showSmile() called');
        // New behavior: slide the avatar/icon to the left and reveal a static 2x3 grid
        blocksVisible = true;

        // Stop typing animation immediately (safe fallback if `fullText` is missing)
        try {
            currentCharIndex = (typeof fullText !== 'undefined') ? fullText.length : (bubbleTextElement ? bubbleTextElement.textContent.length : 0);
        } catch (e) {
            currentCharIndex = bubbleTextElement ? bubbleTextElement.textContent.length : 0;
        }

        // Hide bubble text and icons
        bubbleTextElement.textContent = '';
        if (socialLinks) {
            socialLinks.classList.remove('visible');
            socialLinks.style.opacity = '0';
        }

        // Slide the center icon left to make room for the grid
        if (centerIcon) {
            centerIcon.classList.add('slide-left');
            // Determine slide duration from CSS so JS stays in sync with the visual transition
            const cs = window.getComputedStyle(centerIcon);
            const slideDurStr = cs.getPropertyValue('--center-slide-duration') || cs.transitionDuration || '';
            // parse duration (supports s and ms)
            const parseMs = (s) => {
                if (!s) return 420;
                s = s.trim();
                if (s.endsWith('ms')) return parseFloat(s);
                if (s.endsWith('s')) return parseFloat(s) * 1000;
                return parseFloat(s) || 420;
            };
            const slideMs = parseMs(slideDurStr);
            // add grid-open after the slide animation so avatar movement is visible
            setTimeout(() => { centerIcon.classList.add('grid-open'); }, slideMs + 40);
        }

    // Add color to background and container so the page 'turns color' when grid is shown
        if (backgroundVideo) backgroundVideo.classList.add('color-mode');
        const containerEl = document.querySelector('.container');
        if (containerEl) containerEl.classList.add('color-mode');

        // Trigger avatar color blend and then swap to smile avatars
        avatarNormal.classList.add('transitioning');
        avatarClosed.classList.add('transitioning');
        avatarSmile.classList.add('transitioning');
        avatarSmileClosed.classList.add('transitioning');

        setTimeout(() => {
            try {
                avatarNormal.classList.add('hidden');
                avatarClosed.classList.add('hidden');
                avatarNormal.classList.remove('transitioning');
                avatarClosed.classList.remove('transitioning');

                avatarSmile.classList.add('visible');
                avatarSmileClosed.classList.add('visible');
                avatarSmile.classList.remove('transitioning');
                avatarSmileClosed.classList.remove('transitioning');
            } catch (e) { /* ignore if avatars missing */ }
        }, 200);

        // Reveal the grid. Position it next to the avatar to avoid clipping on odd viewports.
        if (pageGrid) {
            try {
                let left = null;
                let top = null;
                if (centerIcon) {
                    const rect = centerIcon.getBoundingClientRect();
                    // place grid to the right of the avatar with a smaller gap (closer)
                    // reduce gap from 24px to 8px so blocks appear closer to the icon
                    // Move the grid left by 40% of the viewport width
                    left = Math.round(rect.right - window.innerWidth * 0.4);
                    // vertically center the grid near the avatar
                    const gridH = pageGrid.offsetHeight || Math.round((pageGrid.offsetWidth || Math.min(740, Math.round(window.innerWidth * 0.44))) * 0.66);
                    // Move the grid 10% up
                    top = Math.round(rect.top + (rect.height / 2) - (gridH / 2) - window.innerHeight * 0.10);
                } else {
                    // Fallback: center the grid vertically and horizontally, then move up 10%
                    left = Math.round(window.innerWidth / 2);
                    top = Math.round(window.innerHeight * 0.15 - window.innerHeight * 0.10);
                }

                // Clamp to viewport so the grid is always fully visible
                const gridWidth = pageGrid.offsetWidth || Math.min(740, Math.round(window.innerWidth * 0.44));
                const maxLeft = Math.max(8, window.innerWidth - gridWidth - 8);
                left = Math.min(Math.max(8, left), maxLeft);

                const gridHeight = pageGrid.offsetHeight || Math.round(gridWidth * 0.66);
                const maxTop = Math.max(8, window.innerHeight - gridHeight - 8);
                top = Math.min(Math.max(8, top), maxTop);

                pageGrid.style.left = `${left}px`;
                pageGrid.style.top = `${top}px`;
            } catch (e) { /* ignore positioning errors */ }
            pageGrid.setAttribute('aria-hidden', 'false');
            pageGrid.classList.add('visible');
            pageGrid.style.pointerEvents = 'auto';
            pageGrid.style.zIndex = 999999;
            // Staggered reveal: header then blocks
            try {
                const header = pageGrid.querySelector('.grid-header');
                const blocksToReveal = Array.from(pageGrid.querySelectorAll('.grid-block'));
                if (header) {
                    setTimeout(() => header.classList.add('revealed'), 140);
                }
                blocksToReveal.forEach((b, i) => {
                    setTimeout(() => b.classList.add('revealed'), 260 + i * 120);
                });
            } catch (e) { /* ignore reveal errors */ }
            try { console.log('pageGrid bbox:', pageGrid.getBoundingClientRect(), 'computed opacity', window.getComputedStyle(pageGrid).opacity); } catch(e) {}
            // Diagnostic fallback: if CSS or other rules keep the grid hidden, force it visible
            setTimeout(() => {
                try {
                    const comp = window.getComputedStyle(pageGrid);
                    if (comp && (comp.display === 'none' || comp.opacity === '0' || comp.visibility === 'hidden')) {
                        console.warn('Diagnostic: pageGrid computed style after reveal:', {
                            display: comp.display,
                            opacity: comp.opacity,
                            visibility: comp.visibility,
                            left: pageGrid.style.left,
                            top: pageGrid.style.top,
                            zIndex: pageGrid.style.zIndex
                        });
                        // Force visible as a debugging aid
                        pageGrid.style.display = 'grid';
                        pageGrid.style.opacity = '1';
                        pageGrid.style.visibility = 'visible';
                        pageGrid.classList.add('visible');
                    }
                } catch (e) { console.debug('Diagnostic fallback error', e); }
            }, 220);
        }

        // Prepare hover handlers for grid blocks (play video on hover / focus)
        const gridBlocks = document.querySelectorAll('.grid-block');
        gridBlocks.forEach(g => {
            // Only toggle the active class for CSS hover/focus effects (no video playback)
            g.addEventListener('mouseenter', () => g.classList.add('active'));
            g.addEventListener('mouseleave', () => g.classList.remove('active'));
            g.addEventListener('focus', () => g.classList.add('active'));
            g.addEventListener('blur', () => g.classList.remove('active'));

            // Click navigates to the page (preserve existing audio fade behavior)
            g.addEventListener('click', (ev) => {
                ev.stopPropagation();
                const url = g.dataset.url;
                if (url) {
                    // Move icon back to original position and switch to smile/color before navigation
                    try { resetIconToSmile(); } catch(e) { console.debug('resetIconToSmile error', e); }

                    // Fade out any playing music then navigate
                    const backgroundMusic = document.getElementById('background-music');
                    const smileMusic = document.getElementById('smile-music');
                    const currentAudio = blocksVisible ? smileMusic || backgroundMusic : backgroundMusic;
                    const fadeOutDuration = 300;
                    const fadeOutInterval = 30;
                    const steps = fadeOutDuration / fadeOutInterval;
                    let currentStep = 0;
                    const originalVolume = currentAudio ? currentAudio.volume : 0.5;
                    if (currentAudio) {
                        const fadeOutTimer = setInterval(() => {
                            currentStep++;
                            const progress = currentStep / steps;
                            currentAudio.volume = originalVolume * (1 - progress);
                                if (progress >= 1) {
                                clearInterval(fadeOutTimer);
                                try { currentAudio.pause(); } catch(e){}
                                currentAudio.volume = originalVolume;
                                // Wait until the center icon finishes sliding back before navigation
                                if (url) {
                                                // Append cache-busting timestamp to avoid loading a stale cached page
                                                const urlWithParam = url + (url.includes('?') ? '&' : '?') + 'from=home' + '&_=' + Date.now();
                                                // Show cross-fade overlay and fade out the homepage background video immediately to avoid a visual pop
                                                try { const overlay = document.getElementById('crossfade-overlay'); if (overlay) overlay.style.opacity = '1'; } catch(e) {}
                                                try { if (backgroundVideo) backgroundVideo.style.opacity = '0'; } catch(e) {}
                                                navigateAfterSlide(urlWithParam);
                                            }
                            }
                        }, fadeOutInterval);
                    } else {
                        window.location.href = url;
                    }
                }
            });
        });
    }

    function hideSmile() {
        console.log('hideSmile() called');
        blocksVisible = false;
        
        // Reset typing animation and show text and icons again
    bubbleTextElement.textContent = '';
    currentCharIndex = 0;
    if (socialLinks) socialLinks.style.opacity = '';  // Remove inline style to allow CSS to take over
        
    // Fade out smile music and switch back to background music
        const backgroundMusic = document.getElementById('background-music');
        const smileMusic = document.getElementById('smile-music');
        const fadeOutDuration = 500; // 500ms fade out
        const fadeOutInterval = 50; // Update every 50ms
        const steps = fadeOutDuration / fadeOutInterval;
        let currentStep = 0;
        const originalVolume = smileMusic.volume;
        
        // Fade out smile music
        const fadeOutTimer = setInterval(() => {
            currentStep++;
            const progress = currentStep / steps;
            smileMusic.volume = originalVolume * (1 - progress);
            
            if (progress >= 1) {
                clearInterval(fadeOutTimer);
                smileMusic.pause();
                smileMusic.currentTime = 0;
                smileMusic.volume = originalVolume; // Reset volume for later
                
                // Start background music with fade in
                if (backgroundMusic) {
                    backgroundMusic.volume = 0;
                    backgroundMusic.play().catch(e => console.log('Resume audio failed:', e));
                    
                    // Fade in background music
                    let fadeInStep = 0;
                    const fadeInTimer = setInterval(() => {
                        fadeInStep++;
                        const fadeInProgress = fadeInStep / steps;
                        backgroundMusic.volume = originalVolume * fadeInProgress;
                        
                        if (fadeInProgress >= 1) {
                            clearInterval(fadeInTimer);
                            backgroundMusic.volume = originalVolume;
                        }
                    }, fadeOutInterval);
                }
            }
        }, fadeOutInterval);
        
        // Remove color from background video and container
        if (backgroundVideo) backgroundVideo.classList.remove('color-mode');
        const container = document.querySelector('.container');
        if (container) container.classList.remove('color-mode');
        
        // Immediately revert the center icon back to the black-and-white avatars
        try {
            if (avatarNormal) avatarNormal.classList.remove('hidden');
            if (avatarClosed) avatarClosed.classList.remove('hidden');
            if (avatarSmile) avatarSmile.classList.remove('visible');
            if (avatarSmileClosed) avatarSmileClosed.classList.remove('visible');
        } catch (e) { /* ignore if avatars missing */ }

        // Add color blend animation to smile avatars before hiding them
        avatarSmile.classList.add('transitioning');
        avatarSmileClosed.classList.add('transitioning');
        
        // Add color blend animation to normal avatars
        avatarNormal.classList.add('transitioning');
        avatarClosed.classList.add('transitioning');

        // Start the slide-back animation immediately and schedule typing to start after it finishes
        if (centerIcon) {
            try {
                // compute slide duration from CSS
                const cs = window.getComputedStyle(centerIcon);
                const slideDurStr = cs.getPropertyValue('--center-slide-duration') || cs.transitionDuration || '';
                const parseMs = (s) => {
                    if (!s) return 420;
                    s = s.trim();
                    if (s.endsWith('ms')) return parseFloat(s);
                    if (s.endsWith('s')) return parseFloat(s) * 1000;
                    return parseFloat(s) || 420;
                };
                const slideMs = parseMs(slideDurStr);

                // remove grid-open and slide-left to animate back to center
                centerIcon.classList.remove('grid-open');
                centerIcon.classList.remove('slide-left');

                // Start typing after the slide-back animation completes
                setTimeout(() => {
                    try { typeNextCharacter(); } catch(e) { console.debug('typeNextCharacter error after slide-back', e); }
                }, Math.max(40, slideMs + 40));
            } catch (e) {
                // fallback: start typing after a short delay
                setTimeout(() => { try { typeNextCharacter(); } catch(e) {} }, 360);
            }
        } else {
            // no center icon  just start typing after the usual short delay
            setTimeout(() => { try { typeNextCharacter(); } catch(e) {} }, 360);
        }

        // After animation completes, switch the avatars
        setTimeout(() => {
            // Show blinking normal avatars
            avatarNormal.classList.remove('hidden');
            avatarClosed.classList.remove('hidden');
            avatarNormal.classList.remove('transitioning');
            avatarClosed.classList.remove('transitioning');

            // Hide blinking smile avatars
            avatarSmile.classList.remove('visible');
            avatarSmileClosed.classList.remove('visible');
            avatarSmile.classList.remove('transitioning');
            avatarSmileClosed.classList.remove('transitioning');
            
            // Fade out lotus blocks and the page grid (header + blocks)
            try {
                blocks.forEach(block => {
                    try {
                        block.classList.add('fading-out');
                        // reverse typing then hide if that helper exists
                        const label = block.querySelector('.lotus-label');
                        if (label && typeof reverseTypeLotusLabel === 'function') {
                            try {
                                reverseTypeLotusLabel(label, 20, () => {
                                    setTimeout(() => {
                                        block.classList.remove('visible');
                                        block.classList.remove('fading-out');
                                    }, 0);
                                });
                            } catch (e) {
                                // fallback: clear and hide immediately
                                label.textContent = '';
                                setTimeout(() => { block.classList.remove('visible'); block.classList.remove('fading-out'); }, 0);
                            }
                        } else if (label) {
                            // reverseTypeLotusLabel missing: clear label and hide after fade
                            try { label.textContent = ''; } catch(e){}
                            setTimeout(() => { block.classList.remove('visible'); block.classList.remove('fading-out'); }, 260);
                        } else {
                            setTimeout(() => { block.classList.remove('visible'); block.classList.remove('fading-out'); }, 260);
                        }
                    } catch(e) {
                        // ensure one block failure doesn't stop others
                        try { block.classList.remove('visible'); block.classList.remove('fading-out'); } catch(err){}
                    }
                });

                // Fade out the page grid header and each grid-block gracefully
                const header = pageGrid ? pageGrid.querySelector('.grid-header') : null;
                const gridBlocks = pageGrid ? Array.from(pageGrid.querySelectorAll('.grid-block')) : [];
                if (header) header.classList.add('fading-out');
                gridBlocks.forEach(gb => gb.classList.add('fading-out'));

                // After the fade duration, hide the grid entirely and reset attributes
                setTimeout(() => {
                    try {
                        if (pageGrid) {
                            if (header) header.classList.remove('fading-out', 'revealed');
                            gridBlocks.forEach(gb => { gb.classList.remove('fading-out', 'revealed'); gb.classList.remove('active'); });
                            pageGrid.classList.remove('visible');
                            pageGrid.style.pointerEvents = '';
                            pageGrid.style.zIndex = '';
                            pageGrid.setAttribute('aria-hidden', 'true');
                        }
                    } catch(e) { /* ignore */ }
                }, 240);
            } catch(e) {
                console.warn('Error while fading out lotus/grid elements:', e);
                // Best-effort cleanup
                try { if (pageGrid) { pageGrid.classList.remove('visible'); pageGrid.setAttribute('aria-hidden', 'true'); } } catch(_){}
            }

            // Ensure lotus indicators are hidden
            headLotuses.forEach(lotus => lotus.classList.remove('visible'));

            // Start typing animation again (show bubble text and social links)
            // (typing is scheduled to start after slide-back completes)
    }, 320); // Match the animation duration (shortened)
        // Ensure center icon returns to normal and avatar is visible again
        if (centerIcon) { 
            centerIcon.classList.remove('grid-open');
            // remove slide-left after allowing any reverse animation so the slide back is visible
            try {
                const cs = window.getComputedStyle(centerIcon);
                const slideDurStr = cs.getPropertyValue('--center-slide-duration') || cs.transitionDuration || '';
                const parseMs = (s) => {
                    if (!s) return 420;
                    s = s.trim();
                    if (s.endsWith('ms')) return parseFloat(s);
                    if (s.endsWith('s')) return parseFloat(s) * 1000;
                    return parseFloat(s) || 420;
                };
                const slideMs = parseMs(slideDurStr);
                setTimeout(() => { centerIcon.classList.remove('slide-left'); }, Math.max(40, Math.round(slideMs / 3)));
            } catch (e) {
                setTimeout(() => { centerIcon.classList.remove('slide-left'); }, 120);
            }
        }
    }

    // Move the center icon back to its original position and show the smiling, colored avatars.
    function resetIconToSmile() {
        try {
            blocksVisible = false;
            // Move center icon back to center
            if (centerIcon) {
                centerIcon.classList.remove('grid-open');
                centerIcon.classList.remove('slide-left');
            }

            // Ensure video/container are in color mode so avatars look colored
            try { if (backgroundVideo) backgroundVideo.classList.add('color-mode'); } catch(e) {}
            const containerEl = document.querySelector('.container');
            try { if (containerEl) containerEl.classList.add('color-mode'); } catch(e) {}

            // Show smile avatars and hide normal ones
            try {
                if (avatarNormal) avatarNormal.classList.add('hidden');
                if (avatarClosed) avatarClosed.classList.add('hidden');
                if (avatarSmile) avatarSmile.classList.add('visible');
                if (avatarSmileClosed) avatarSmileClosed.classList.add('visible');
            } catch(e) { console.debug('resetIconToSmile avatar toggle error', e); }

            // Optionally start smile music if present
            try {
                const smileMusic = document.getElementById('smile-music');
                if (smileMusic) {
                    smileMusic.currentTime = 0;
                    smileMusic.play().catch(e => {/* ignore autoplay errors */});
                }
            } catch(e) {}

            // Fade out the page grid header and blocks so they disappear smoothly before navigation
            try {
                const pageGridEl = document.getElementById('pageGrid');
                if (pageGridEl) {
                    const header = pageGridEl.querySelector('.grid-header');
                    const gridBlocks = pageGridEl ? Array.from(pageGridEl.querySelectorAll('.grid-block')) : [];
                    if (header) header.classList.add('fading-out');
                    gridBlocks.forEach(gb => gb.classList.add('fading-out'));

                    // After the fade duration, clean up classes and hide the grid
                    setTimeout(() => {
                        try {
                            if (header) header.classList.remove('fading-out', 'revealed');
                            gridBlocks.forEach(gb => { gb.classList.remove('fading-out', 'revealed', 'active'); gb.classList.remove('visible'); });
                            pageGridEl.classList.remove('visible');
                            pageGridEl.style.pointerEvents = '';
                            pageGridEl.style.zIndex = '';
                            pageGridEl.setAttribute('aria-hidden', 'true');
                        } catch(e) { /* ignore cleanup errors */ }
                    }, 240);
                }
            } catch(e) { console.debug('resetIconToSmile grid fade error', e); }
        } catch(e) { console.debug('resetIconToSmile error', e); }
    }

    // Helper: navigate only after the center icon slide-back completes.
    function navigateAfterSlide(navigateTo) {
        try {
            if (!navigateTo) return;
            const center = document.querySelector('.center-icon');
            if (!center) { window.location.href = navigateTo; return; }

            const cs = window.getComputedStyle(center);
            const slideDurStr = cs.getPropertyValue('--center-slide-duration') || cs.transitionDuration || '';
            const parseMs = (s) => {
                if (!s) return 420;
                s = s.trim();
                if (s.endsWith('ms')) return parseFloat(s);
                if (s.endsWith('s')) return parseFloat(s) * 1000;
                return parseFloat(s) || 420;
            };
            const slideMs = parseMs(slideDurStr);
            // Add a small buffer to ensure the visual transition completes
            const buffer = 60;
            setTimeout(() => { window.location.href = navigateTo; }, slideMs + buffer);
        } catch (e) {
            try { window.location.href = navigateTo; } catch(_){ }
        }
    }

    // Attach click handlers only if avatars exist to avoid ReferenceErrors stopping execution
    if (avatarNormal && typeof avatarNormal.addEventListener === 'function') {
        avatarNormal.addEventListener('click', function(e) {
            e.stopPropagation();
            showSmile();
        });
    }
    if (avatarClosed && typeof avatarClosed.addEventListener === 'function') {
        avatarClosed.addEventListener('click', function(e) {
            e.stopPropagation();
            showSmile();
        });
    }
    if (avatarSmile && typeof avatarSmile.addEventListener === 'function') {
        avatarSmile.addEventListener('click', function(e) {
            e.stopPropagation();
            hideSmile();
        });
    }
    if (avatarSmileClosed && typeof avatarSmileClosed.addEventListener === 'function') {
        avatarSmileClosed.addEventListener('click', function(e) {
            e.stopPropagation();
            hideSmile();
        });
    }

    // Also allow clicking the whole center icon area to toggle the grid state
    if (centerIcon && typeof centerIcon.addEventListener === 'function') {
        centerIcon.addEventListener('click', function(e) {
            e.stopPropagation();
            if (blocksVisible) {
                hideSmile();
            } else {
                showSmile();
            }
        });
    }

    // Audio autoplay functionality (UI removed)
    // volume UI elements removed; only passive audio playback remains
    const backgroundMusic = document.getElementById('background-music');
    
    // Opening intro enabled  keep panels so the cinematic split animation can play.
    // Previously this IIFE removed the panels immediately which prevented the split from showing.
    // If you want to skip the intro panels in future, set localStorage.setItem('skipIntro','1') or
    // add logic here to remove them conditionally.
    /*
    (function removeIntroPanelsNow(){
        try {
            const introLeft = document.getElementById('movieIntroLeft');
            const introRight = document.getElementById('movieIntroRight');
            if (introLeft) introLeft.remove();
            if (introRight) introRight.remove();
        } catch (e) { console.debug('Could not remove intro panels:', e); }
    })();
    */
    
    if (backgroundMusic) {
        backgroundMusic.volume = 0.5; // Set default volume to 50%
        console.log('Audio element found:', backgroundMusic);
        
        let audioStarted = false;
        
        // Function to start audio
        function startAudio() {
            if (!audioStarted && backgroundMusic && !blocksVisible) {
                audioStarted = true;
                console.log('Starting audio...');
                const playPromise = backgroundMusic.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('Audio is now playing!');
                        })
                        .catch(error => {
                            console.log('Audio play error:', error);
                            audioStarted = false; // Reset so we can try again
                        });
                }
            }
        }
        
        // Add event listeners without 'once' so they persist
        document.addEventListener('mousemove', startAudio);
        document.addEventListener('touchstart', startAudio);
        document.addEventListener('click', startAudio);
        document.addEventListener('keydown', startAudio);
        
        // We'll start audio after the intro sequence finishes (see runIntroThenStart)
        
        // Listen for when audio ends to ensure it loops
        backgroundMusic.addEventListener('ended', () => {
            console.log('Audio ended, restarting loop');
            backgroundMusic.currentTime = 0;
            backgroundMusic.play().catch(e => console.log('Loop play failed:', e));
        });
    }

    // Ensure we start in black-and-white state (no color-mode) until user clicks
    try {
        if (backgroundVideo && !blocksVisible) backgroundVideo.classList.remove('color-mode');
        const containerEl = document.querySelector('.container');
        if (containerEl && !blocksVisible) containerEl.classList.remove('color-mode');
    } catch (e) {}

    // Intro sequence: show name overlay, then fade into the page. Start typing/audio after intro.
    function runIntroThenStart() {
        const intro = document.getElementById('intro-overlay');
        const centerIconEl = document.querySelector('.center-icon');
        try {
            if (!intro) {
                // No overlay, start immediately
                try { typeNextCharacter(); } catch(e) {}
                try { startAudio(); } catch(e) {}
                return;
            }

            // Make the center icon non-interactive while the intro runs
            try { if (centerIconEl) centerIconEl.classList.add('no-interact'); } catch(e) {}

            // Helper to run the existing intro reveal / typing / fade sequence
            function continueIntro() {
                // Staggered reveal: first name then last name
                const nameEl = intro.querySelector('.intro-name');
                if (nameEl) {
                    // Reveal first quickly
                    setTimeout(() => { nameEl.classList.add('reveal-first'); }, 200);
                    // Then reveal last shortly after
                    setTimeout(() => { nameEl.classList.add('reveal-last'); }, 600);
                }

                // Start the intro code typing after the last-name reveal transition completes
                try {
                    // reveal-last is added at ~600ms and each name part uses a 1200ms transition
                    // so wait until that transition finishes before starting the typed code to avoid layout jitter
                    const revealLastDelay = 600; // ms when reveal-last class is added
                    const nameTransitionMs = 1200; // matches CSS transition duration for the name parts
                    const buffer = 80; // small buffer so the visual settle is complete
                    setTimeout(() => {
                        try {
                            const introCodeEl = intro.querySelector('.intro-code');
                            if (introCodeEl) introCodeEl.classList.add('reveal');
                        } catch(e) {}
                        try { runIntroCodeSequence(120); } catch(e) { console.debug('runIntroCodeSequence error', e); }
                    }, revealLastDelay + nameTransitionMs + buffer);
                } catch(e) { console.debug('runIntroCodeSequence schedule error', e); }

                // Hold the fully revealed name for ~6 seconds total, then fade the overlay
                const fadeStartMs = 6000;
                const fadeDurationMs = 1800; // matches CSS transition set above
                const removalBufferMs = 120; // small buffer after fade completes before removing overlay

                setTimeout(() => {
                    // add fade class to intro so the overlay blurs/fades
                    intro.classList.add('intro-fade');

                    // Trigger movie panels to open at the moment the intro starts to fade
                    try {
                        const leftPanel = document.getElementById('movieIntroLeft');
                        const rightPanel = document.getElementById('movieIntroRight');
                        const panelAnimationMs = 2500; // should match CSS keyframe duration for openLeft/openRight
                        let panelsHandled = false;

                        const onPanelsDone = () => {
                            if (panelsHandled) return; panelsHandled = true;
                            try { if (leftPanel) leftPanel.remove(); } catch(e) {}
                            try { if (rightPanel) rightPanel.remove(); } catch(e) {}
                            // Promote overlay above UI once panels are removed so it sits on top for the remaining fade
                            try { intro.classList.add('intro-overlay-top'); } catch(e) {}
                            // Re-enable center icon interactions once panels are done
                            try { if (centerIconEl) centerIconEl.classList.remove('no-interact'); } catch(e) {}
                            // Promote the center icon above the intro overlay so avatars are visible
                            try { if (centerIconEl) centerIconEl.classList.add('icon-top'); } catch(e) {}
                        };

                        try {
                            // Add the class that runs the open animation
                            if (leftPanel) leftPanel.classList.add('open');
                            if (rightPanel) rightPanel.classList.add('open');

                            // Listen for animationend on either panel
                            if (leftPanel && leftPanel.addEventListener) leftPanel.addEventListener('animationend', onPanelsDone, { once: true });
                            if (rightPanel && rightPanel.addEventListener) rightPanel.addEventListener('animationend', onPanelsDone, { once: true });
                        } catch(e) { /* ignore */ }

                        // Fallback timeout to ensure panels are removed even if events don't fire
                        setTimeout(onPanelsDone, panelAnimationMs + 120);
                    } catch(e) { console.debug('Panel open trigger error', e); }
                }, fadeStartMs);

                // Remove overlay and start audio/typing after fade completes
                setTimeout(() => {
                    try { intro.remove(); } catch(e) { intro.style.display = 'none'; }
                    // Ensure center icon is interactive (in case panels didn't fire an event)
                    try { if (centerIconEl) centerIconEl.classList.remove('no-interact'); } catch(e) {}
                    try { startAudio(); } catch(e) {}
                    try { typeNextCharacter(); } catch(e) { console.debug('typeNextCharacter error after intro', e); }
                }, fadeStartMs + fadeDurationMs + removalBufferMs);
            }

            // Start the intro immediately; when the overlay blur/fade starts we'll trigger the panels to open
            continueIntro();
        } catch (e) {
            console.debug('Intro run error', e);
            try { typeNextCharacter(); } catch(e) {}
            try { startAudio(); } catch(e) {}
        }
    }
    // Start the intro sequence now that the function is defined
    try { runIntroThenStart(); } catch(e) { console.debug('runIntroThenStart invocation error', e); }
    
    // Volume UI removed: keeping audio playback logic but no visible controls

    // Parallax effect for grid thumbnails: nudge the image on mousemove for depth
    (function attachThumbnailParallax(){
        const blocks = document.querySelectorAll('.grid-block');
        blocks.forEach(block => {
            const img = block.querySelector('img.static-thumb');
            if (!img) return;

            let rafId = null;
            let targetX = 0, targetY = 0, targetS = 1;
            let currentX = 0, currentY = 0, currentS = 1;

            function updateVars(){
                // lerp to target for smooth, gentler motion
                currentX += (targetX - currentX) * 0.08;
                currentY += (targetY - currentY) * 0.08;
                currentS += (targetS - currentS) * 0.06;

                img.style.setProperty('--px', currentX.toFixed(2) + 'px');
                img.style.setProperty('--py', currentY.toFixed(2) + 'px');
                img.style.setProperty('--ps', currentS.toFixed(3));

                rafId = requestAnimationFrame(updateVars);
            }

            function onMouseMove(e){
                const rect = block.getBoundingClientRect();
                const px = (e.clientX - rect.left) / rect.width; // 0..1
                const py = (e.clientY - rect.top) / rect.height; // 0..1

                // gentler map to range: -4px .. 4px for x, -3px .. 3px for y, scale 1..1.0125
                targetX = (px - 0.5) * 8; 
                targetY = (py - 0.5) * 6;
                targetS = 1 + Math.max(0, 0.0125 * (1 - Math.abs(px - 0.5) * 2));

                if (!rafId) updateVars();
            }

            function resetParallax(){
                targetX = 0; targetY = 0; targetS = 1;
                // ensure one last frame to snap back
                if (!rafId) updateVars();
                // cancel after a short delay to avoid keeping RAF running
                setTimeout(() => { if (rafId) { cancelAnimationFrame(rafId); rafId = null; } }, 120);
            }

            block.addEventListener('mousemove', onMouseMove);
            block.addEventListener('mouseenter', (e) => { onMouseMove(e); });
            block.addEventListener('mouseleave', resetParallax);
            block.addEventListener('blur', resetParallax);
        });
    })();

    // Parallax effect - background follows cursor (subtle) to match other pages
    (function setupParallax(){
        const bg = document.getElementById('background-video');
        if (!bg) return;
        const maxOffset = 6; // pixels of maximum translation
        const update = (e) => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const offsetX = (e.clientX - w/2) / (w/2);
            const offsetY = (e.clientY - h/2) / (h/2);
            const translateX = offsetX * maxOffset;
            const translateY = offsetY * maxOffset;
            bg.style.transform = `translate(${translateX}px, ${translateY}px)`;
        };
        document.addEventListener('mousemove', update);
    })();

    // Ensure navigation uses sliding closing panels (left/right) like About/Internship pages
    (function setupClosingPanels(){
        // Closing outro disabled on homepage  no-op.
    })();
</script>
</html>
