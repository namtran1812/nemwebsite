<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>About Me - Nems Website</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Ballet&display=swap" rel="stylesheet">
    <style>
        /* Page-level root styles */
        body {
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            font-family: Arial, sans-serif;
            padding: 20px 20px;
            /* page-level scrolling disabled so only the content block scrolls */
            overflow: hidden;
            position: relative;
            cursor: url('images/homeimages/cursor.png') 42 42, pointer;
        }

        /* Ensure the bub cursor is applied globally and not overridden by nested elements */
        * { cursor: url('images/homeimages/cursor.png') 42 42, pointer !important; }

        /* Page root gets grayscale/blur animations so fixed UI (like audio control)
           can sit outside and remain visible/colored even when page is BW */
        :root {
            --bar-slide-duration: 1.2s;
            --bar-slide-ease: ease-in-out;
            /* visible width for the persistent bars (user requested 180px) */
            --bar-width: 180px; /* was 220px */
            --bar-overhang: 60px; /* how much the bar extends past the viewport edge */
            --bar-total: calc(var(--bar-width) + var(--bar-overhang));
        }

        .page-root {
            width: 100%;
            min-height: 100vh;
            /* Show page in full color by default (disable black-and-white state) */
            filter: none;
            transition: filter 0.8s ease-in-out;
        }

        /* color-mode is still accepted by scripts but is a no-op visually */
        .page-root.color-mode {
            filter: none;
        }

    .background-video {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        /* Cover the viewport so the video always fills the screen (may crop to maintain aspect ratio) */
        object-fit: cover;
        object-position: center center;
        z-index: -1;
        transform-origin: center center;
          /* Slightly zoom the background for a tighter composition. Parallax will
              apply translate while preserving this scale. */
          transform: translate(0,0) scale(1.06);
        filter: blur(0px) grayscale(0%);
        transition: opacity 520ms ease-in-out, filter 0.2s ease-in-out, transform 0.2s ease;
        opacity: 1;
    }

    /* (Removed blurred background layer per user request) */

            /* .page-root.color-mode continues to be supported but has no visual change */
            .page-root.color-mode .background-video {
                filter: blur(0px) grayscale(0%);
            }

            /* Allow the background video to be toggled to color even when it sits outside .page-root
               by giving it a class. This is useful because the video element is placed before
               the .page-root wrapper and can't be selected with a parent selector. */
            .background-video.color {
                filter: blur(0px) grayscale(0%);
            }

            /* overlay removed so the background video is shown without a black tint */
            .page-root .overlay {
                position: fixed;
                /* expand off-screen to match the movie intro bars and avoid visible gaps */
                top: -6vh;
                left: calc(-1 * var(--bar-overhang));
                right: calc(-1 * var(--bar-overhang));
                height: calc(100vh + 12vh);
                background: transparent; /* no tint */
                z-index: 5; /* sit above the video but below content (content uses z-index >=20) */
                pointer-events: none; /* allow clicks to pass through */
                transition: background 0.3s ease-in-out;
            }

            /* Ensure other elements also remove grayscale when page-root.color-mode is active */
            .page-root.color-mode .content-block,
            .page-root.color-mode .header,
            .page-root.color-mode .avatar-about {
                filter: none;
            }

            .page-root.color-mode .avatar-about-closed {
                filter: none;
            }

        /* Intro transitions removed: open/close keyframes deleted so page appears instantly */

        .header {
            text-align: center;
            margin-bottom: 40px;
            animation: float 3s ease-in-out infinite;
        }

        .header h1 {
            font-family: 'Press Start 2P', cursive;
            color: #E78FA5;
            font-size: 24px;
            margin-bottom: 20px;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-5px);
            }
        }

        /* Movie intro CSS (matched to homepage) */
        :root { --bar-slide-duration: 1.2s; --bar-slide-ease: ease-in-out; }

        .movie-intro-overlay {
            position: fixed;
            top: -6vh;
            left: 0;
            width: 100%;
            height: calc(100vh + 12vh);
            background-color: #000;
            z-index: 9999;
            pointer-events: none;
        }

        .movie-intro-left, .movie-intro-right {
            position: fixed;
            top: -6vh;
            height: calc(100vh + 12vh);
            background: #000;
            z-index: 900;
            pointer-events: none;
            transition: transform var(--bar-slide-duration) var(--bar-slide-ease);
        }

        .movie-intro-left { left: calc(-1 * var(--bar-overhang)); width: calc(50% + var(--bar-overhang)); }
        .movie-intro-right{ right: calc(-1 * var(--bar-overhang)); width: calc(50% + var(--bar-overhang)); }
        .movie-intro-left.open { animation: openLeft 2.5s ease-in-out forwards; }
        .movie-intro-right.open { animation: openRight 2.5s ease-in-out forwards; }

        @keyframes openLeft {
            0% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(calc(-100vw - var(--bar-overhang))); opacity: 1; }
        }

        @keyframes openRight {
            0% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(calc(100vw + var(--bar-overhang))); opacity: 1; }
        }

        @keyframes closeLeft {
            0% { transform: translateX(calc(-100vw - var(--bar-overhang))); }
            100% { transform: translateX(0); }
        }

        @keyframes closeRight {
            0% { transform: translateX(calc(100vw + var(--bar-overhang))); }
            100% { transform: translateX(0); }
        }

        /* Foreground class applied to the center icon to keep it above panels.
           Ensure the post-intro promoted state (`icon-top`) uses the same visual
           transform so the icon looks identical before and after the panels open. */
        .center-icon.closing-foreground,
        .center-icon.icon-top {
            /* Match homepage stacking so the promoted icon sits above overlays */
            z-index: 11000 !important;
            /* Do not scale the icon; keep size identical to homepage */
            transform: translateZ(0);
            transition: transform 360ms ease-in-out;
        }

        /* Ensure the promoted center container doesn't block interactions
           with the content block. The container can stay visually on top
           (for clipping/stacking) but pointer-events should pass through
           except for the avatar image itself which must remain clickable. */
        .center-icon.icon-top {
            pointer-events: none;
        }
        .center-icon.icon-top img {
            /* Re-enable pointer events for the actual avatar image */
            pointer-events: auto;
        }

        /* During the cinematic intro, the JS applies a 'no-interact' class
           to the center icon to make it completely non-interactive. This
           prevents accidental clicks while the bars are closed. When the
           panels finish opening the JS removes this class and the avatar
           becomes interactive again. */
        .center-icon.no-interact {
            pointer-events: none !important;
        }
        .center-icon.no-interact img {
            pointer-events: none !important;
            /* remove pointer cursor while non-interactive */
            cursor: default !important;
        }

        /* Chapter label (pixelated) shown before panels open — use the same
           reveal/fade timings as the homepage intro-name for consistency. */
        .chapter-label {
            position: fixed;
            /* place at the same position as the dropdown/menu button */
            left: 20px;
            top: 8px;
            transform: none;
            text-align: left;
            margin-left: 0;
            /* Add inner left padding so the typed text has a margin from the element edge */
            padding-left: 8px;
            font-family: 'Press Start 2P', cursive;
            /* Slightly reduced responsive sizing per request */
            font-size: clamp(8px, 1.4vw, 10px);
            /* Slightly larger line spacing for multi-line typed text */
            line-height: 1.6;
            color: #ffffff;
            text-transform: lowercase;
            letter-spacing: 1px;
            z-index: 10020;
            opacity: 0.18; /* start faint but visible like intro name */
            filter: blur(4px) brightness(0.6);
            /* Allow transitions so the chapter label can animate when fading out */
            transition: filter 1800ms ease, opacity 1800ms ease, transform 1800ms ease;
            -webkit-font-smoothing: none;
            will-change: opacity, filter;
            pointer-events: none;
            text-shadow: 0 8px 22px rgba(231,143,165,0.28), 0 0 10px rgba(231,143,165,0.18);
            white-space: pre-wrap;
        }

    /* Keep the centering transform when revealing so it doesn't shift horizontally */
    .chapter-label.reveal { opacity: 1; filter: none; transform: none; }

        /* Fade/blur stage when panels begin to open */
    /* When fading, apply blur/opacity/translate so the printed text blurs out */
    .chapter-label.fade { opacity: 0; filter: blur(6px) brightness(0.6); transform: translateY(-8px) scale(0.995); transition: filter 1800ms ease, opacity 1800ms ease, transform 1800ms ease; }

        /* Add persistent vertical frame bars like the homepage */
        .container::before,
        .container::after {
            content: '';
            position: fixed;
            top: -6vh;
            /* collapse by default so no visible bars */
            width: 0;
            height: calc(100vh + 12vh);
            background-color: transparent; /* no black bars */
            z-index: 100; /* placeholder stacking */
            pointer-events: none; /* allow clicks to pass through to dropdown/menu */
            transition: width 0.6s ease-in-out;
            pointer-events: none;
        }

        .container::before {
            left: calc(-1 * var(--bar-overhang));
            /* shift the bar outward so its outer edge extends past the viewport */
        }

        .container::after {
            right: calc(-1 * var(--bar-overhang));
            /* shift the bar outward so its outer edge extends past the viewport */
        }

        /* Persistent bars are disabled on this page; color-mode rules are no-ops here. */
        .page-root.color-mode .container::before,
        .page-root.color-mode .container::after {
            width: 0;
        }

        .movie-intro-right.closing {
            animation: closeRight 2.5s ease-in-out forwards;
        }

        .movie-intro-right.open {
            animation: openRight 2.5s ease-in-out forwards;
        }

        .movie-intro-right.slide-out {
            transform: translateX(calc(100vw + var(--bar-total))) !important;
        }

        /* Ballet 'About Me' decorative label that overlaps the content block
           It sits after the .content-block in the DOM so we can reveal it when the
           content block has the .active class. */
        .about-me-ballet {
            position: absolute;
            top: calc(120px - 60px); /* moved slightly higher above the content block */
            left: 200px; /* moved a bit left from previous position */
            margin-right: 40px;
            font-family: 'Ballet', 'Brush Script MT', cursive;
            font-size: 56px;
            color: #fff;
            z-index: 60; /* above the content block (which is z-index:50) */
            pointer-events: none;
            text-transform: none;
            letter-spacing: 0.5px;
            /* Layered text-shadows for depth and legibility */
            text-shadow:
                0 1px 0 rgba(255,255,255,0.03), /* tiny highlight to make edges pop */
                0 2px 2px rgba(0,0,0,0.36),    /* near shadow for crispness */
                0 8px 20px rgba(0,0,0,0.6);    /* soft large shadow for depth */
            /* subtle drop-shadow filter to improve separation from video backgrounds */
            filter: drop-shadow(0 10px 24px rgba(0,0,0,0.28));
            -webkit-font-smoothing: antialiased;
            opacity: 0;
            /* start off-screen (match the content-block initial translateX) */
            transform: translateX(-100vw) translateY(0);
            transition: opacity 0.8s ease-in-out, transform 0.8s ease-in-out, text-shadow 0.45s ease;
        }

        /* When the content block is active, reveal the Ballet label and nudge it right */
        .content-block.active ~ .about-me-ballet {
            opacity: 1;
                /* animate to the content-block final translate (6vw) plus a slightly reduced extra offset,
                    and nudge up a bit so the label sits higher. */
                transform: translateX(calc(6vw + 25vw)) translateY(-1.2vh);
        }

            /* Intro name style (Ballet) for About/Me reveal — mirror homepage intro-name */
            .about-intro-name {
                /* container holds the spans; spans are positioned independently */
                position: relative;
                pointer-events: none;
            }
            .about-intro-name .about-intro-first,
            .about-intro-name .about-intro-last {
                position: fixed;
                left: 50%;
                top: 52%;
                transform: translate(-50%, -50%);
                display: inline-block;
                opacity: 0.08;
                filter: blur(4px) brightness(0.6);
                transition: opacity 1200ms ease, filter 1200ms ease, transform 1200ms ease;
                -webkit-font-smoothing: antialiased;
                /* Ballet font and sizing to match homepage 'Nam Tran' */
                font-family: 'Ballet', 'Brush Script MT', cursive;
                color: white;
                font-size: clamp(28px, 8vw, 120px);
                letter-spacing: 1px;
                text-shadow: 0 8px 22px rgba(231,143,165,0.28), 0 0 10px rgba(231,143,165,0.18);
            }
            /* Place 'About' behind the icon (above bars but below icon) */
    /* Position the two words so the avatar sits between them. Keep them on the same vertical level and
       maintain consistent horizontal spacing (About at 40%, Me at 60%). Adjust these if you want
       the icon to be slightly off-center. */
            .about-intro-name .about-intro-first { z-index: 10020; left: 35%; top: 40%; }
            /* Place 'Me' in front of the icon and lower it to 60% for vertical spacing */
            .about-intro-name .about-intro-last { z-index: 11020; left: 60%; top: 60%; }

            /* Keep the same centering transform when revealing so the words don't shift position */
            .about-intro-name.reveal-first .about-intro-first { opacity: 1; filter: none; transform: translate(-50%, -50%); }
            .about-intro-name.reveal-last .about-intro-last { opacity: 1; filter: none; transform: translate(-50%, -50%); }
            /* Fade/blur stage when panels begin to open — keep centering translate */
            .about-intro-name.fade {
                opacity: 0 !important;
                filter: blur(6px) brightness(0.6) !important;
                transform: translate(-50%, -50%) translateY(-8px) scale(0.995) !important;
                transition: filter 1800ms ease, opacity 1800ms ease, transform 1800ms ease;
            }
            /* The spans are position:fixed; apply fade/blur directly to them so the effect is visible */
            .about-intro-name.fade .about-intro-first,
            .about-intro-name.fade .about-intro-last {
                opacity: 0 !important;
                filter: blur(10px) brightness(0.6) !important;
                -webkit-filter: blur(10px) brightness(0.6) !important;
                transform: translate(-50%, -50%) translateY(-8px) scale(0.995) !important;
                transition: filter 1800ms ease, opacity 1800ms ease, transform 1800ms ease;
                will-change: opacity, filter, transform;
            }
            /* Mirror homepage behaviour: when the movie overlay gets .intro-fade, blur/fade the chapter label and About/Me */
            #movieIntroOverlay.intro-fade ~ #chapterLabel,
            #movieIntroOverlay.intro-fade ~ .about-intro-name,
            #movieIntroOverlay.intro-fade ~ .about-intro-name .about-intro-first,
            #movieIntroOverlay.intro-fade ~ .about-intro-name .about-intro-last {
                filter: blur(6px) brightness(0.6);
                -webkit-filter: blur(6px) brightness(0.6);
                opacity: 0;
                transform: translateY(-8px) scale(0.995);
                transition: filter 1800ms ease, opacity 1800ms ease, transform 1800ms ease;
            }
            /* text-shadow fallback to emulate blur for browsers that ignore filter on fixed elements */
            .about-intro-name.fade .about-intro-first,
            .about-intro-name.fade .about-intro-last {
                text-shadow: 0 0 18px rgba(0,0,0,0.6), 0 0 12px rgba(231,143,165,0.18) !important;
            }

        @keyframes movieIntroOpen {
            0% {
                opacity: 1;
                clip-path: inset(0);
            }
            100% {
                opacity: 0;
                clip-path: inset(0 0 0 0);
            }
        }

        .dropdown-menu {
            position: fixed;
            top: 3px;
            left: 20px;
            /* place the dropdown above most UI but below the cinematic closing panels */
            z-index: 11000;
            animation: float 3s ease-in-out infinite;
            /* hidden by default — will fade/slide into view when .visible is added */
            opacity: 0;
            transform: translateY(-12px);
            transition: opacity 900ms cubic-bezier(.2,.8,.2,1), transform 900ms cubic-bezier(.2,.8,.2,1);
            pointer-events: none;
        }

        /* Audio control (copied from index.html) */
        /* audio control UI removed - audio elements remain for passive playback */

        .dropdown-button {
            background-color: transparent;
            background-image: url('images/homeimages/fullcloud.png');
            background-size: 100%;
            background-position: center;
            background-repeat: no-repeat;
            color: #E78FA5;
            padding: 60px 80px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            border: none;
            cursor: url('images/homeimages/cursor.png') 42 42, pointer;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.6));
            animation: float 3s ease-in-out infinite;
            display: none; /* hidden by default; shown when .dropdown-menu.visible */
        }

        /* Ensure the dropdown content is interactive when opened; the menu/button
           interactivity is handled by the .visible class so we can animate the fade. */
        .dropdown-content {
            pointer-events: auto;
            /* ensure dropdown content is above normal UI but below closing panels */
            z-index: 11010;
        }

        /* Show the button after intro finishes or avatar click — fade in the whole menu */
        .dropdown-menu.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto; /* now interactive */
        }

        .dropdown-menu.visible .dropdown-button {
            display: block;
        }

        .dropdown-button:hover {
            background-color: transparent;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-image: url('images/dropdowncloud.png');
            /* adjust cloud artwork scale */
            background-size: 120%;
            background-position: center;
            background-repeat: no-repeat;
            min-width: 150px;
            padding: 40px 20px 44px 20px;
            /* ensure menu content is above other UI and interactive */
            z-index: 11111;
            border-radius: 5px;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.6));
        }

        .dropdown-content a {
            color: #333;
            padding: 7px 0;
            margin: 0 auto;
            text-decoration: none;
            display: block;
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            line-height: 10px;
            text-align: center;
            transition: color 0.3s ease;
            cursor: url('images/homeimages/cursor.png') 42 42, pointer;
        }

        .dropdown-content a:hover {
            color: #E78FA5;
        }

        .dropdown-content a.active {
            color: #E78FA5;
            font-weight: bold;
        }

        .dropdown-menu.menu-open .dropdown-content {
            display: block;
        }

        .container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            /* nudge avatar slightly down from previous position */
            padding-top: 5.4vh;
            width: 100%;
            height: 100%;
            position: relative; /* ensure absolutely positioned Ballet label is relative to this container */
        }

        .center-icon {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 40px; /* match homepage spacing so avatar sits at same vertical position */
        }

        .center-icon img {
            max-width: 75vw;
            max-height: 75vh;
            width: auto;
            height: auto;
            object-fit: contain;
            z-index: 20; /* match homepage avatar stacking */
            transition: opacity 0.3s ease-in-out;
        }

        .avatar-about {
            cursor: url('images/homeimages/cursor.png') 42 42, pointer;
            animation: aboutBlink 2.8s infinite, float 3s ease-in-out infinite;
            animation-delay: 0s, 0s;
            /* Match homepage avatar size and stacking */
            max-width: 75vw;
            max-height: 75vh;
            width: auto;
            height: auto;
            object-fit: contain;
            z-index: 50;
            position: relative;
            filter: grayscale(100%);
            transition: filter 0.8s ease-in-out, opacity 0.2s ease-in-out;
        }

        .avatar-about-closed {
            position: absolute;
            max-width: 75vw;
            max-height: 75vh;
            width: auto;
            height: auto;
            object-fit: contain;
            z-index: 50;
            cursor: url('images/homeimages/cursor.png') 42 42, pointer;
            animation: aboutClosedBlink 2.8s infinite, float 3s ease-in-out infinite;
            animation-delay: 0s, 0s;
            filter: grayscale(100%);
            transition: filter 0.8s ease-in-out, opacity 0.2s ease-in-out;
        }

        @keyframes aboutBlink {
            0% { opacity: 1; }
            71.43% { opacity: 1; }
            71.5% { opacity: 0; }
            100% { opacity: 0; }
        }

        @keyframes aboutClosedBlink {
            0% { opacity: 0; }
            71.43% { opacity: 0; }
            71.5% { opacity: 1; }
            100% { opacity: 1; }
        }

        @keyframes slideAvatarRight {
            0% { transform: translateX(0); }
            100% { transform: translateX(40vw); }
        }

        @keyframes slideContentIn {
            0% { transform: translateX(-100vw); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideAvatarBack {
            0% { transform: translateX(40vw); }
            100% { transform: translateX(0); }
        }

        @keyframes slideContentOut {
            0% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(-100vw); opacity: 0; }
        }

        .center-icon {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
        }

        .avatar-container {
            position: relative;
            z-index: 100;
            transition: transform 0.8s ease-in-out;
            /* nudge avatars slightly upward so they're visually centered on the About page */
            top: -2vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .avatar-container.shifted {
            /* move the avatar further right when expanded (bigger nudge)
               Adjust left by 5vw so the avatar lines up with the content block's new position. */
            transform: translateX(calc(33vw - 5vw));
        }

        .content-block {
            position: fixed;
            /* shift the block slightly left so layout visually aligns with avatar */
            left: -5vw;
            top: 120px; /* moved down slightly */
            width: 65vw;
            /* make content block shorter so it doesn't stretch full page height */
            height: 70vh;
                    /* Solid black tint for the entire content block (no gradient) with
                        a tiled grain overlay that multiplies over the black tint. */
                    background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='1.6' numOctaves='4' stitchTiles='stitch'/><feColorMatrix type='matrix' values='0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 0.36'/></filter><rect width='100%' height='100%' fill='black' filter='url(%23n)'/></svg>");
                    background-repeat: repeat;
                    background-size: 120px 120px;
        /* While the intro panels are closed, bring the icon to the front and slightly scale up */
        .center-icon.closing-foreground {
            z-index: 11000 !important;
            /* Keep the same size as homepage — do not scale up */
            transform: translateZ(0);
            transition: transform 360ms ease-in-out, z-index 0ms;
        }
                    background-position: 0 0;
                    background-color: rgba(0,0,0,0.72);
                    background-blend-mode: multiply;
            border: 1px solid rgba(255,255,255,0.06);
            padding: 24px 32px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
            overscroll-behavior: contain; /* prevent scroll chaining to the page */
            overflow-x: hidden;
            z-index: 50;
            opacity: 0;
            transform: translateX(-100vw);
            transition: transform 0.8s ease-in-out, opacity 0.8s ease-in-out;
            color: #d0d0d0;
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            line-height: 1.8;
            letter-spacing: 0.3px;
            /* Keep edges sharp and add subtle inner sheen and drop shadow to simulate glass
               without using backdrop-filter (no blur applied to the video). */
            border-radius: 12px;
            box-shadow: 0 12px 36px rgba(0,0,0,0.65), inset 0 1px 0 rgba(255,255,255,0.02);
            background-clip: padding-box;
            /* keep vertical scrolling enabled; only hide horizontal overflow for sheen */
            overflow-x: hidden;
            scrollbar-width: none;
        }

        /* Subtle sheen overlay to emulate a glossy glass surface (no blur) */
        .content-block::before {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            border-radius: inherit;
            /* subtle sheen; lower opacity so the dark tint remains visible */
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0));
            mix-blend-mode: overlay;
            opacity: 0.6;
            /* place the sheen behind the content */
            z-index: 0;
        }

        /* Ensure text and interactive elements inside the content block render above the sheen */
        .content-block * {
            position: relative;
            z-index: 2;
        }

        /* Matte / grain overlay to give the content block a subtle textured (matte) appearance */
          /* grain now applied as a background layer on the .content-block itself so it
              consistently covers the entire scrollable area. */

        /* side image removed - no styles needed */

        .content-block::-webkit-scrollbar {
            display: none;
        }

        .content-block.active {
            opacity: 1;
            /* shift the content block by the same small nudge so the gap remains unchanged */
            transform: translateX(8vw);
        }

        .content-block h2 {
            font-size: 12px;
            font-weight: 400;
            margin-bottom: 20px;
            color: #E78FA5;
            letter-spacing: 1px;
            border-bottom: 2px solid #E78FA5;
            padding-bottom: 10px;
        }

        .content-block h3 {
            font-size: 10px;
            font-weight: 400;
            margin-top: 25px;
            margin-bottom: 12px;
            color: #E78FA5;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #E78FA5;
            padding-bottom: 8px;
        }

        .content-block p {
            margin-bottom: 12px;
            text-align: left;
            opacity: 0.95;
            background: rgba(231, 143, 165, 0.05);
            padding: 10px 12px;
            border-left: 2px solid #E78FA5;
        }

        .content-block p strong {
            color: #E78FA5;
            font-weight: 600;
        }

        .content-block ul {
            margin-left: 0;
            margin-bottom: 8px;
            list-style: none;
            background: transparent;
            padding: 12px 0;
            border-left: none;
        }

        .content-block li:last-child {
            margin-bottom: 0;
        }

        .content-section {
            background: transparent;
            border: none;
            padding: 8px 0;
            margin-bottom: 8px;
        }

        /* Scroll reveal / dropdown animation: headings and sections animate in as they enter
           the visible area of the #contentBlock scroll container. Prefers-reduced-motion respected. */
        .content-block h2,
        .content-block h3,
        .content-section {
            will-change: transform, opacity;
            opacity: 0;
            transform: translateY(12px);
            transition: transform 420ms cubic-bezier(.2,.8,.2,1), opacity 420ms ease;
        }

        .content-block h2.visible,
        .content-block h3.visible,
        .content-section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        @media (prefers-reduced-motion: reduce) {
            .content-block h2,
            .content-block h3,
            .content-section { transition: none !important; transform: none !important; opacity: 1 !important; }
        }

        /* Subtle pink tint glow on hover/focus for each content section (no lift) */
        .content-section {
            display: block;
            width: 100%;
            position: relative;
            pointer-events: auto;
            padding: 12px 8px;
            transition: transform 420ms cubic-bezier(.2,.8,.2,1), opacity 420ms ease, background 220ms ease, box-shadow 220ms ease;
        }

        /* Only show the hover glow for sections that have been revealed */
        .content-section.visible:hover,
        .content-section.visible:focus-within {
            /* brighter pink tint */
            background: linear-gradient(180deg, rgba(231,143,165,0.14), rgba(231,143,165,0.06));
            box-shadow: 0 18px 48px rgba(231,143,165,0.16), inset 0 0 0 1px rgba(231,143,165,0.12);
            border-radius: 8px;
            cursor: default;
        }

        /* Make sections keyboard-focusable appearance accessible (brighter) */
        .content-section.visible:focus-within {
            outline: 2px solid rgba(231,143,165,0.26);
            outline-offset: 4px;
        }

        .content-section p {
            background: transparent;
            border: none;
            padding: 5px 0;
            margin-bottom: 8px;
        }

        .content-section p:last-child {
            margin-bottom: 0;
        }

        .content-section ul {
            background: transparent;
            border: none;
            padding: 0 0 0 15px;
            margin-bottom: 0;
        }

        .content-block li {
            margin-bottom: 8px;
            position: relative;
            padding-left: 15px;
            font-size: 8px;
        }

        .content-block li:before {
            content: "▸";
            position: absolute;
            left: 0;
            color: #E78FA5;
        }
        /* ---------- Glassmorphism (About page only) ---------- */
        /* Apply a subtle frosted glass effect to the main content areas
           while explicitly excluding avatar, dropdown menu, and audio UI */
        /* Apply card styling to header and content-sections but do NOT blur them. */
        .page-root .content-section,
        .page-root .header {
            background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
            border: 1px solid rgba(255,255,255,0.08);
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.45);
            border-radius: 10px;
        }

        /* Content block: confined frosted-glass effect. This applies backdrop blur
           only inside the card area so the page/video edges remain sharp. */
        .page-root .content-block {
            backdrop-filter: blur(6px) saturate(115%);
            -webkit-backdrop-filter: blur(6px) saturate(115%);
        }

        /* Keep avatar, dropdown, and audio controls visually intact (no blur/glass) */
        .avatar-about,
        .avatar-about-closed,
        .dropdown-menu,
        .audio-control,
        .audio-control * {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            filter: none !important;
            box-shadow: none !important;
            background: none !important;
        }

        /* Slight spacing and rounding adjustments to blend with glass style */
        .content-block {
            padding: 24px 32px; /* a touch more padding for card-like feel */
            border-radius: 12px;
        }

        .content-section {
            padding: 12px 10px;
            margin-bottom: 12px;
            border-radius: 8px;
        }

    </style>
</head>
<body>
    <!-- Foreground Background Video (sharp, slightly zoomed) -->
    <video class="background-video" autoplay muted loop playsinline>
        <source src="images/aboutmeimages/aboutmebackground.mp4?v=6" type="video/mp4">
    </video>

    <script>
    // Fade intro removed to ensure the movie-intro panels control the page reveal.
    // The opening bars are handled by the controlledIntro logic later in the file.
    </script>

    <!-- Background Audio (about page) -->
    <audio id="background-music" loop crossorigin="anonymous">
     <source src="images/aboutmeimages/aboutmeaudio.mp3" type="audio/mpeg">
     Your browser does not support the audio element.
    </audio>
    <!-- audio control UI removed from page (volume button hidden) -->

    <!-- Movie Intro Overlay and page content are wrapped so the audio control stays colored -->
    <div class="page-root">
        <!-- subtle full-screen black tint overlay (10%) -->
        <div class="overlay" aria-hidden="true"></div>
    <!-- Movie Intro Overlay and panels -->
    <div id="movieIntroOverlay" class="movie-intro-overlay" aria-hidden="true"></div>
    <div id="movieIntroLeft" class="movie-intro-left" aria-hidden="true"></div>
    <div id="movieIntroRight" class="movie-intro-right" aria-hidden="true"></div>
    <!-- Chapter label shown before panels open -->
    <div id="chapterLabel" class="chapter-label"></div>

    <div class="dropdown-menu">
        <button class="dropdown-button">Menu</button>
        <div class="dropdown-content">
            <a href="index.html">Home</a>
            <a href="about.html">About Me</a>
            <a href="internship.html">Internship</a>
            <a href="leadership.html">Leadership</a>
            <a href="technical.html">Technical</a>
            <a href="creative.html">Creative</a>
            <a href="questions.html">Questions</a>
        </div>
    </div>
    <div class="container">
        <div class="center-icon">
            <div class="avatar-container" id="avatarContainer">
                <img class="avatar-about" id="avatarImage" src="images/homeimages/fullbodyiconsmile-transparent.png" alt="Avatar">
                <img class="avatar-about-closed" id="avatarImageClosed" src="images/homeimages/fullbodyiconsmileclosed-transparent.png" alt="Avatar Closed">
            </div>
        </div>
        <div class="content-block" id="contentBlock">
            <h3>Introduction</h3>
            
            <div class="content-section">
                <p>I am Nam Tran, a Computer Science & Economics undergraduate at the University of Florida, originally from Ho Chi Minh City, Vietnam, and currently based in Gainesville, Florida. I am interested in building reliable, scalable, and well-designed technology solutions, with a focus on software engineering, systems, artificial intelligence, and full-stack development.</p>
            </div>
            
            <div class="content-section">
                <p>I enjoy working on projects that combine technical depth with thoughtful design. I am especially drawn to clean system architectures, expressive interfaces, and user experiences that feel intentional and intuitive. Outside of coursework, I often explore side projects involving pixel art and minimalist UI, using design as a way to complement and humanize technical work.</p>
            </div>
            
            <div class="content-section">
                <p>Beyond tech, I have a strong creative side. I enjoy dancing, writing poetry, and vlogging, which help me stay expressive, balanced, and inspired. These creative outlets influence how I think about storytelling, rhythm, and emotion in both design and software. On a lighter note, my favorite dish is bun bo Hue, and I firmly believe no debugging session is complete without good food—this one just happens to be my fuel of choice.</p>
            </div>

            <h3>Education</h3>
            <div class="content-section">
                <p><strong>University of Florida (UF) — Gainesville, FL, USA</strong></p>
                <ul>
                    <li>Computer Science & Economics Major</li>
                    <li>August 2023 – Expected May 2027</li>
                </ul>
            </div>

            <div class="content-section">
                <p><strong>Tran Dai Nghia High School for the Gifted — Ho Chi Minh City, Vietnam</strong></p>
                <ul>
                    <li>English Major</li>
                    <li>August 2016 - May 2023</li>
                </ul>
            </div>

            <h3>Artist Statement</h3>
            <div class="content-section">
                <p>My work explores the intersection of technology, design, and storytelling. I am drawn to building software that is not only functional, but expressive—where systems are clean, interfaces are intentional, and every detail serves a purpose.</p>
            </div>
            
            <div class="content-section">
                <p>Influenced by my background growing up in Saigon and my training in computer science, I approach creation as both an engineer and a designer. I value simplicity, structure, and clarity, often gravitating toward minimalist aesthetics, pixel art, and thoughtful user experiences. Whether I am writing code or designing an interface, I aim to create work that feels approachable, human, and quietly meaningful.</p>
            </div>
            
            <div class="content-section">
                <p>For me, technology is a creative medium—a way to translate ideas into form, logic into interaction, and personal perspective into something others can experience.</p>
            </div>
        </div>
        <div class="about-me-ballet">About Me</div>
    </div>
    </div> <!-- .page-root -->
</body>
<script>
    // Dropdown menu toggle
    const dropdownMenu = document.querySelector('.dropdown-menu');
    const dropdownButton = document.querySelector('.dropdown-button');
    const dropdownLinks = document.querySelectorAll('.dropdown-content a');

    // Diagnostic: confirm the script executed
    try { console.log('[about] script loaded'); } catch(e) {}

    // Get current page filename
    const currentPage = window.location.pathname.split('/').pop() || 'index.html';

    // Highlight current page in dropdown
    dropdownLinks.forEach(link => {
        const href = link.getAttribute('href');
        if (href === currentPage || (currentPage === '' && href === 'index.html')) {
            link.classList.add('active');
        }
    });
    // Diagnostic: log how many dropdown links we found so it's easy to confirm the script ran
    try { console.log('[about] dropdownLinks count ->', dropdownLinks && dropdownLinks.length); } catch(e) {}

    // Controlled intro: mirror homepage logic — no DOM clone, use classes and animationend
    (function controlledIntro() {
        try {
            const params = new URLSearchParams(window.location.search || '');
            if (params.get('skipIntro') === '1') {
                const cb = document.getElementById('contentBlock');
                if (cb) cb.classList.add('active');
                try { revealContentSectionsNow(); } catch(e){}
                // If skipping the intro, make the menu visible immediately
                try { if (dropdownMenu) dropdownMenu.classList.add('visible'); } catch(e){}
                return;
            }

            const left = document.getElementById('movieIntroLeft');
            const right = document.getElementById('movieIntroRight');
            const overlay = document.getElementById('movieIntroOverlay');
            const center = document.querySelector('.center-icon');
            const contentBlock = document.getElementById('contentBlock');

            if (!left || !right || !overlay || !center || !contentBlock) {
                // If required nodes missing, skip the cinematic panels but still
                // reveal the dropdown menu so navigation is available.
                console.debug('[about] intro nodes missing — skipping cinematic intro');
                try { if (dropdownMenu) dropdownMenu.classList.add('visible'); } catch (e) {}
                return;
            }

            // Make center non-interactive and promote it above the panels
            try { center.classList.add('no-interact'); } catch(e){}
            try { center.classList.add('closing-foreground'); } catch(e){}

            // Track whether the panels have started opening so injected elements
            // added later can respond and fade immediately.
            let panelsOpeningStarted = false;

            // Show the chapter label briefly while bars are closed — type it
            try {
                const chapter = document.getElementById('chapterLabel');
                if (chapter) {
                    // small typing helper modeled after homepage typing
                    function typeStringInto(el, str, speed = 70, delay = 0, cb) {
                        let i = 0;
                        const t = setTimeout(function step() {
                            if (i < str.length) {
                                el.textContent += str[i++];
                                setTimeout(step, speed);
                            } else if (typeof cb === 'function') cb();
                        }, delay);
                    }

                    // Delay slightly before typing so it doesn't flash instantly
                    setTimeout(() => {
                        try {
                            // prepare the element and use the CSS reveal class for visual consistency
                            chapter.textContent = '';
                            chapter.classList.add('reveal');
                                try {
                                // Ensure the typed lines appear instantly without transition
                                chapter.style.transition = 'none';
                                chapter.style.opacity = '1';
                                chapter.style.filter = 'none';
                                // Do not force centering here — leave positioning to CSS (left/top)
                                chapter.style.transform = 'none';
                            } catch (ie) { /* non-fatal */ }
                            // Type the phrase like print("chapter 1") but show only the inner text
                            // Type a three-line sequence with line breaks
                            typeStringInto(chapter, 'print("closing the previous chapter...")\n', 60, 0, () => {
                                setTimeout(() => {
                                    try {
                                        // type the time.sleep line on the next line
                                        typeStringInto(chapter, 'time.sleep(1)\n', 60, 0, () => {
                                            setTimeout(() => {
                                                try {
                                                    // final line
                                                    typeStringInto(chapter, 'print("opening chapter one")', 60, 0, () => {
                                                        try {
                                                            // After typing completes, insert the Ballet-style About/Me name
                                                            const existing = document.querySelector('.about-intro-name');
                                                            if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
                                                            const nameEl = document.createElement('div');
                                                            nameEl.className = 'about-intro-name';
                                                            nameEl.innerHTML = '<span class="about-intro-first">About</span> <span class="about-intro-last">Me</span>';
                                                            // Place the name element in the page-root so z-indexing is predictable
                                                            const pageRoot = document.querySelector('.page-root') || document.body;
                                                            pageRoot.appendChild(nameEl);

                                                            // Mirror homepage timings: reveal-first at ~200ms, reveal-last at ~600ms
                                                            setTimeout(() => { nameEl.classList.add('reveal-first'); }, 200);
                                                            setTimeout(() => { nameEl.classList.add('reveal-last'); }, 600);
                                                            // If panels already started opening, fade the name immediately
                                                            try {
                                                                if (typeof panelsOpeningStarted !== 'undefined' && panelsOpeningStarted) {
                                                                    nameEl.classList.remove('reveal-first');
                                                                    nameEl.classList.remove('reveal-last');
                                                                    nameEl.classList.add('fade');
                                                                    nameEl.style.transition = 'filter 1800ms ease, opacity 1800ms ease, transform 1800ms ease';
                                                                    nameEl.style.opacity = '0';
                                                                    nameEl.style.filter = 'blur(6px) brightness(0.6)';
                                                                    nameEl.style.transform = 'translate(-50%, -50%) translateY(-8px) scale(0.995)';
                                                                }
                                                            } catch (ie) { /* non-fatal */ }
                                                        } catch (e) { console.debug('inject About/Me name failed', e); }
                                                    });
                                                } catch (e) { console.debug('final typing failed', e); }
                                            }, 200);
                                        });
                                    } catch (e) { console.debug('time.sleep typing failed', e); }
                                }, 200);
                            });
                        } catch (innerErr) { console.debug('chapter typing inner error', innerErr); }
                    }, 200);
                }
            } catch(e) { console.debug('chapter label typing error', e); }

            // Wait 3 seconds with the bars closed, then fade the overlay and open the panels.
            try {
                overlay.style.transition = 'opacity 420ms ease-in-out';
            } catch (e) { console.debug('[about] overlay transition setup error', e); }

            // Keep panels closed for 8000ms before starting the reveal sequence
            setTimeout(() => {
                try {
                    overlay.style.opacity = '0';
                    console.debug('[about] overlay fade started after 5000ms delay');
                } catch (e) { console.debug('[about] overlay fade error after delay', e); }

                // Small delay so the overlay fade is noticeable; then trigger the open animation.
                // We purposely DO NOT fade elements here; they will be faded exactly when
                // the panels begin opening so the chapter label and About/Me animate together.

                setTimeout(() => {
                    try {
                        console.debug('[about] starting panel open (apply fade to chapter & name, then open panels)');
                        try { overlay.classList.add('intro-fade'); } catch(e) {}
                    // Apply fade/blur to chapter label and About/Me name at the same moment
                    try {
                        const fadeTransition = 'filter 1800ms ease, opacity 1800ms ease, transform 1800ms ease';
                        const chapter = document.getElementById('chapterLabel');
                        const aboutName = document.querySelector('.about-intro-name');
                        if (chapter) {
                            chapter.classList.remove('reveal');
                            chapter.classList.add('fade');
                            chapter.style.transition = fadeTransition;
                        }
                        if (aboutName) {
                            aboutName.classList.remove('reveal-first');
                            aboutName.classList.remove('reveal-last');
                            aboutName.classList.add('fade');
                            aboutName.style.transition = fadeTransition;
                        }
                        // Force a single reflow so both elements start their transitions together
                        void document.body.offsetWidth;
                        if (chapter) {
                            chapter.style.opacity = '0';
                            chapter.style.filter = 'blur(6px) brightness(0.6)';
                            chapter.style.transform = 'translateY(-8px) scale(0.995)';
                        }
                        if (aboutName) {
                            // Minimal, consistent behavior: use CSS-driven fade like the homepage
                            try {
                                aboutName.classList.remove('reveal-first');
                                aboutName.classList.remove('reveal-last');
                                aboutName.classList.add('fade');
                                aboutName.style.transition = fadeTransition;
                                // also set final state on child spans so the visual matches the initial reveal
                                try {
                                    const f = aboutName.querySelector('.about-intro-first');
                                    const l = aboutName.querySelector('.about-intro-last');
                                    if (f) {
                                        f.style.setProperty('opacity', '0', 'important');
                                        f.style.setProperty('filter', 'blur(10px) brightness(0.6)', 'important');
                                        f.style.setProperty('-webkit-filter', 'blur(10px) brightness(0.6)', 'important');
                                        f.style.setProperty('transform', 'translate(-50%, -50%) translateY(-8px) scale(0.995)', 'important');
                                    }
                                    if (l) {
                                        l.style.setProperty('opacity', '0', 'important');
                                        l.style.setProperty('filter', 'blur(10px) brightness(0.6)', 'important');
                                        l.style.setProperty('-webkit-filter', 'blur(10px) brightness(0.6)', 'important');
                                        l.style.setProperty('transform', 'translate(-50%, -50%) translateY(-8px) scale(0.995)', 'important');
                                    }
                                } catch (ie) { /* non-fatal */ }
                            } catch (ie) { /* non-fatal */ }
                        }
                    } catch (ie) { /* non-fatal */ }

                    // Mark panels opening started so any injected name after this point fades immediately
                    try { panelsOpeningStarted = true; } catch(e){}

                    left.classList.add('open');
                    right.classList.add('open');
                    // (fade already applied above) 
                    // Reveal the dropdown earlier (midway through the open animation)
                    // so the menu doesn't feel delayed. This adds the visible class
                    // ~1.2s after the open starts. panelDone will still add visible as
                    // a safety when animations finish.
                    try {
                        setTimeout(() => { if (dropdownMenu) dropdownMenu.classList.add('visible'); }, 1200);
                    } catch(e) { console.debug('dropdown early reveal failed', e); }
                    
                    // Also make the center icon interactive partway through the open
                    // animation so the user can click it as soon as the bars feel
                    // 'open' (match the menu early reveal timing).
                    try {
                        setTimeout(() => { if (center) center.classList.remove('no-interact'); }, 1200);
                    } catch (e) { console.debug('early re-enable of center icon failed', e); }
                    // fallback inline animation to ensure animation starts across browsers
                    try { left.style.animation = 'openLeft 2.5s ease-in-out forwards'; } catch(e) {}
                    try { right.style.animation = 'openRight 2.5s ease-in-out forwards'; } catch(e) {}

                    let panelsHandled = false;
                    const panelDone = () => {
                        if (panelsHandled) return; panelsHandled = true;
                        console.debug('[about] panelDone fired — cleaning up');
                        try { if (left.parentNode) left.parentNode.removeChild(left); } catch(e){}
                        try { if (right.parentNode) right.parentNode.removeChild(right); } catch(e){}
                        try { if (overlay.parentNode) overlay.parentNode.removeChild(overlay); } catch(e){}
                        try { center.classList.remove('no-interact'); } catch(e){}
                        try { center.classList.remove('closing-foreground'); } catch(e){}
                        // Rely on class-based styling for visual state; do not force inline transforms.
                        // Keep the icon visually promoted so it's not clipped by overlays
                        try { center.classList.add('icon-top'); } catch(e){}
                        // Reveal the dropdown menu after the panels finish opening
                        try { if (dropdownMenu) dropdownMenu.classList.add('visible'); } catch(e){}
                        // Do NOT reveal content-block here; it should appear on avatar click.
                        console.debug('[about] panels finished — content remains hidden until avatar click');
                        // Remove chapter label from DOM
                        try { const chapter = document.getElementById('chapterLabel'); if (chapter && chapter.parentNode) chapter.parentNode.removeChild(chapter); } catch(e) {}
                        // Remove injected About/Me intro name if present
                        try { const aboutName = document.querySelector('.about-intro-name'); if (aboutName && aboutName.parentNode) aboutName.parentNode.removeChild(aboutName); } catch(e) {}
                    };

                    // Listen for animationend on either panel as primary signal
                    if (left.addEventListener) left.addEventListener('animationend', panelDone, { once: true });
                    if (right.addEventListener) right.addEventListener('animationend', panelDone, { once: true });

                    // Fallback timeout in case animationend doesn't fire
                    setTimeout(panelDone, 2600);
                } catch (e) {
                    console.debug('panel open trigger error', e);
                    try { contentBlock.classList.add('active'); } catch(e){}
                    try { revealContentSectionsNow(); } catch(e){}
                }
            }, 90); // ~1 frame + small buffer
            }, 8000);
        } catch (e) { console.debug('controlledIntro error', e); }
    })();

    // When the visible button is clicked, toggle the actual dropdown content
    dropdownButton.addEventListener('click', function(e) {
        e.stopPropagation();
        dropdownMenu.classList.toggle('menu-open');
    });

    // Add navigation to dropdown links
    // Closing outro removed: navigate immediately when requested.
    function runClosingOutro(navigateTo) {
        console.log('[about] runClosingOutro requested ->', navigateTo);
        if (navigateTo) {
            let isHomeTarget = false;
            try {
                isHomeTarget = (navigateTo.indexOf('index.html') !== -1 || navigateTo === '' || navigateTo === '/');
                if (isHomeTarget) sessionStorage.removeItem('introShown');
            } catch (e) { /* ignore */ }
            // Play closing panels animation that covers the entire viewport (including the icon),
            // then navigate when the animation finishes. If panels were removed earlier we
            // create temporary ones so the closing animation is visible.
            try {
                let left = document.getElementById('movieIntroLeft');
                let right = document.getElementById('movieIntroRight');
                let overlay = document.getElementById('movieIntroOverlay');
                const center = document.querySelector('.center-icon');

                // Helper to create panel nodes if missing
                const ensurePanels = () => {
                    if (!overlay) {
                        overlay = document.createElement('div');
                        overlay.id = 'movieIntroOverlay';
                        overlay.className = 'movie-intro-overlay';
                        document.body.appendChild(overlay);
                    }
                    if (!left) {
                        left = document.createElement('div');
                        left.id = 'movieIntroLeft';
                        left.className = 'movie-intro-left';
                        document.body.appendChild(left);
                    }
                    if (!right) {
                        right = document.createElement('div');
                        right.id = 'movieIntroRight';
                        right.className = 'movie-intro-right';
                        document.body.appendChild(right);
                    }
                };

                ensurePanels();

                console.log('[about] panels ensured:', { left, right, overlay });

                // Ensure panels sit above the icon while closing; put panels above the overlay
                try { left.style.zIndex = 13050; } catch(e){}
                try { right.style.zIndex = 13050; } catch(e){}
                try { overlay.style.zIndex = 13040; } catch(e){}

                // Keep the overlay transparent so the panels close over the actual page content
                // (we don't want a full-screen black background behind the panels).
                try { overlay.style.backgroundColor = 'transparent'; overlay.style.opacity = '0'; overlay.style.pointerEvents = 'none'; } catch(e){}

                // Force the left/right panels to start off-screen so the close animation
                // (which animates from offscreen -> 0) is visible even when panels were created now.
                try { left.style.transform = 'translateX(calc(-100vw - var(--bar-overhang)))'; } catch(e){}
                try { right.style.transform = 'translateX(calc(100vw + var(--bar-overhang)))'; } catch(e){}
                // Reset the avatar/icon to the default (smiling/home) state so the bars
                // close over the default icon instead of the expanded/about avatar.
                let closingCenterClone = null;
                let contentBlockEl = null;
                let avatarImageEl = null;
                try {
                    avatarImageEl = document.getElementById('avatarImage');
                    const avatarImageClosedEl = document.getElementById('avatarImageClosed');
                    const avatarContainerEl = document.getElementById('avatarContainer');
                    contentBlockEl = document.getElementById('contentBlock');
                    const pageRootEl = document.querySelector('.page-root');
                    const bgVideoEl = document.querySelector('.background-video');

                    if (avatarImageEl) avatarImageEl.src = 'images/homeimages/fullbodyiconsmile-transparent.png';
                    if (avatarImageClosedEl) avatarImageClosedEl.src = 'images/homeimages/fullbodyiconsmileclosed-transparent.png';
                    if (avatarContainerEl) avatarContainerEl.classList.remove('shifted');
                    if (contentBlockEl) contentBlockEl.classList.remove('active');
                    // Force reflow then remove color-mode on next frame (mirrors collapse behavior)
                    void document.body.offsetWidth;
                    requestAnimationFrame(() => {
                        try { if (pageRootEl) pageRootEl.classList.remove('color-mode'); } catch(e){}
                        try { if (bgVideoEl) bgVideoEl.classList.remove('color'); } catch(e){}
                        try { if (dropdownMenu) dropdownMenu.classList.remove('menu-open'); } catch(e){}
                    });
                    try { isExpanded = false; } catch(e){}
                } catch(e) { console.log('Could not reset avatar before closing outro', e); }

                // Start closing sequence only after avatar/content block has visually collapsed
                const startCloseSequence = () => {
                    if (center) {
                        if (isHomeTarget) {
                            try { center.classList.remove('icon-top'); } catch(e){}
                            try { center.classList.add('closing-foreground'); } catch(e){}
                            // ensure panels still sit above when targeting home
                            try { left.style.zIndex = 13050; } catch(e){}
                            try { right.style.zIndex = 13050; } catch(e){}
                        } else {
                            try { center.classList.remove('closing-foreground'); } catch(e){}
                            try { center.classList.add('icon-top'); } catch(e){}
                            try {
                                const avatarImg = avatarImageEl;
                                const rect = (avatarImg && avatarImg.getBoundingClientRect) ? avatarImg.getBoundingClientRect() : center.getBoundingClientRect();
                                if (avatarImg) {
                                    closingCenterClone = document.createElement('img');
                                    closingCenterClone.id = 'closingCenterClone';
                                    closingCenterClone.src = avatarImg.src || 'images/homeimages/fullbodyiconsmile-transparent.png';
                                    const cs = closingCenterClone.style;
                                    cs.position = 'fixed';
                                    cs.left = rect.left + 'px';
                                    cs.top = rect.top + 'px';
                                    cs.width = Math.round(rect.width) + 'px';
                                    cs.height = Math.round(rect.height) + 'px';
                                    cs.objectFit = 'contain';
                                    cs.margin = '0';
                                    cs.boxSizing = 'border-box';
                                    cs.pointerEvents = 'none';
                                    cs.willChange = 'transform, opacity';
                                    cs.background = 'transparent';
                                    cs.transform = 'none';
                                    cs.zIndex = '2147483647';
                                    try {
                                        const srcCS = window.getComputedStyle(avatarImg);
                                        if (srcCS) {
                                            cs.borderRadius = srcCS.borderRadius || '';
                                            cs.filter = srcCS.filter || '';
                                            cs.boxShadow = srcCS.boxShadow || '';
                                        }
                                    } catch (ee) { /* ignore */ }
                                    // Hide the original center visually while keeping it in the DOM
                                        center.style.visibility = 'hidden';
                                        // Disable interactivity while outro runs
                                        try { center.style.pointerEvents = 'none'; } catch(e){}
                                        document.body.appendChild(closingCenterClone);
                                    console.log('[about] created center img clone at', rect, 'src=', closingCenterClone.src);
                                } else {
                                    console.log('[about] avatarImage not found; cannot create image clone');
                                }
                            } catch(e) { console.log('Could not create center image clone', e); }
                        }
                    }

                    // start close animations (use keyframe names present in CSS)
                    console.log('[about] starting closeLeft/closeRight animations');
                    // Ensure panels are solid black and sit above the page content
                    try { left.style.background = '#000'; left.style.pointerEvents = 'none'; } catch(e){}
                    try { right.style.background = '#000'; right.style.pointerEvents = 'none'; } catch(e){}
                    try { left.style.zIndex = 13050; } catch(e){}
                    try { right.style.zIndex = 13050; } catch(e){}
                    try { left.style.animation = 'closeLeft 2.5s ease-in-out forwards'; } catch(e){}
                    try { right.style.animation = 'closeRight 2.5s ease-in-out forwards'; } catch(e){}

                    let handled = false;
                    const onDone = (ev) => {
                        if (handled) return; handled = true;
                        console.log('[about] closing animation finished', ev && ev.type);
                        // cleanup any temporary inline z-index or clone we added for the icon
                        try { if (center && center.style) center.style.zIndex = ''; } catch(e){}
                        try { if (closingCenterClone && closingCenterClone.parentNode) closingCenterClone.parentNode.removeChild(closingCenterClone); } catch(e){}
                        try { if (center) { center.style.visibility = ''; center.style.pointerEvents = ''; } } catch(e){}
                        try { window.location.href = navigateTo; } catch(e) { window.location = navigateTo; }
                    };

                    // Listen for animationend on either panel and then navigate
                    try { left.addEventListener && left.addEventListener('animationend', onDone, { once: true }); } catch(e){}
                    try { right.addEventListener && right.addEventListener('animationend', onDone, { once: true }); } catch(e){}

                    // Fallback timeout in case animationend doesn't fire
                    setTimeout(onDone, 2600);
                };

                // If the avatar was shifted/expanded, wait for the avatar container's
                // transform transition to finish so the clone captures the collapsed size.
                try {
                    const avatarContainerEl = document.getElementById('avatarContainer');
                    let waited = false;
                    const safeStart = (ms) => setTimeout(() => { if (!waited) { waited = true; startCloseSequence(); } }, ms);

                    if (avatarContainerEl && avatarContainerEl.addEventListener) {
                        // Try to read computed transition duration for the transform property
                        let durMs = 300; // default fallback
                        try {
                            const cs = window.getComputedStyle(avatarContainerEl);
                            const td = cs.transitionDuration || cs.transition || '';
                            const parts = (td || '').split(',').map(s => s.trim());
                            // find first duration in seconds/ms and parse
                            if (parts.length) {
                                const first = parts[0];
                                if (first.endsWith('ms')) durMs = parseFloat(first);
                                else if (first.endsWith('s')) durMs = parseFloat(first) * 1000;
                            }
                        } catch (ee) { /* ignore */ }

                        const onTransEnd = (ev) => {
                            if (ev.propertyName === 'transform' || ev.propertyName === 'opacity') {
                                if (!waited) { waited = true; startCloseSequence(); }
                            }
                        };
                        avatarContainerEl.addEventListener('transitionend', onTransEnd, { once: true });
                        // fallback: start after computed duration + small buffer
                        safeStart(durMs + 60);
                    } else if (contentBlockEl && contentBlockEl.addEventListener) {
                        // as a secondary fallback, wait for contentBlock transition
                        const waitFor = (ev) => {
                            if (ev.propertyName === 'transform' || ev.propertyName === 'opacity') {
                                if (!waited) { waited = true; startCloseSequence(); }
                            }
                        };
                        contentBlockEl.addEventListener('transitionend', waitFor, { once: true });
                        safeStart(320);
                    } else {
                        // no element to wait on — start immediately next frame
                        setTimeout(startCloseSequence, 40);
                    }
                } catch(e) { console.log('Could not wait for content collapse, starting close immediately', e); startCloseSequence(); }

                // start close animations (use keyframe names present in CSS)
                console.log('[about] starting closeLeft/closeRight animations');
                // Ensure panels are solid black and sit above the page content
                try { left.style.background = '#000'; left.style.pointerEvents = 'none'; } catch(e){}
                try { right.style.background = '#000'; right.style.pointerEvents = 'none'; } catch(e){}
                try { left.style.zIndex = 13050; } catch(e){}
                try { right.style.zIndex = 13050; } catch(e){}
                try { left.style.animation = 'closeLeft 2.5s ease-in-out forwards'; } catch(e){}
                try { right.style.animation = 'closeRight 2.5s ease-in-out forwards'; } catch(e){}

                let handled = false;
                const onDone = (ev) => {
                    if (handled) return; handled = true;
                    console.log('[about] closing animation finished', ev && ev.type);
                    // cleanup any temporary inline z-index or clone we added for the icon
                    try { if (center && center.style) center.style.zIndex = ''; } catch(e){}
                    try { if (closingCenterClone && closingCenterClone.parentNode) closingCenterClone.parentNode.removeChild(closingCenterClone); } catch(e){}
                    try { if (center) center.style.visibility = ''; } catch(e){}
                    try { window.location.href = navigateTo; } catch(e) { window.location = navigateTo; }
                };

                // Listen for animationend on either panel and then navigate
                try { left.addEventListener && left.addEventListener('animationend', onDone, { once: true }); } catch(e){}
                try { right.addEventListener && right.addEventListener('animationend', onDone, { once: true }); } catch(e){}

                // Fallback timeout in case animationend doesn't fire
                setTimeout(onDone, 2600);
                return;
            } catch (e) { /* ignore and navigate */ }
            window.location.href = navigateTo;
        }
    }

    // Add navigation to dropdown links (use closing outro before navigating)
    dropdownLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation(); // avoid the document click handler racing and hiding UI
            const href = this.getAttribute('href');
            try { console.log('[about] dropdown link clicked ->', href); } catch(e) {}
            runClosingOutro(href);
        });
    });

    // Close dropdown when clicking outside (ignore clicks on avatar and content block)
    document.addEventListener('click', function(event) {
        const avatarContainer = document.getElementById('avatarContainer');
        const contentBlockEl = document.getElementById('contentBlock');
        // If the click is inside the dropdown, avatar, or content block, do nothing.
        if (dropdownMenu.contains(event.target) || (avatarContainer && avatarContainer.contains(event.target)) || (contentBlockEl && contentBlockEl.contains(event.target))) {
            return;
        }

    // Otherwise close the dropdown content but keep the visible button shown
    dropdownMenu.classList.remove('menu-open');
    // NOTE: do not remove the 'visible' class here — keep the button visible
    });

    // Avatar interaction
    const avatarContainer = document.getElementById('avatarContainer');
    const avatarImage = document.getElementById('avatarImage');
    const avatarImageClosed = document.getElementById('avatarImageClosed');
    const contentBlock = document.getElementById('contentBlock');
    const movieIntroLeft = document.querySelector('.movie-intro-left');
    const movieIntroRight = document.querySelector('.movie-intro-right');
    let isExpanded = false;

    // By default we keep the cinematic intro panels so the controlledIntro can run.
    // Only remove the panels immediately when the page is requested with ?skipIntro=1
    try {
        const params2 = new URLSearchParams(window.location.search || '');
        const skipIntroNow = params2.get('skipIntro') === '1';
        if (skipIntroNow) {
            if (movieIntroLeft) movieIntroLeft.classList.add('active');
            if (movieIntroRight) movieIntroRight.classList.add('active');
            const introLeft = document.querySelector('.movie-intro-left');
            const introRight = document.querySelector('.movie-intro-right');
            if (introLeft) introLeft.remove();
            if (introRight) introRight.remove();
        }
    } catch (e) {
        console.debug('Could not conditionally remove intro panels:', e);
    }

    // Also disable the opening blur animation on the page root so there is no
    // transient blur/clean animation on load.
    try {
        const pageRootEl = document.querySelector('.page-root');
        if (pageRootEl) pageRootEl.style.animation = 'none';
    } catch (e) {
        console.debug('Could not disable pageRoot animation:', e);
    }

    // Preload the "about" avatar images so the swap is instant on click
    try {
        const aboutOpenSrc = 'images/aboutmeimages/fullbodyiconabout-transparent.png';
        const aboutClosedSrc = 'images/aboutmeimages/fullbodyiconaboutclosed-transparent.png';
        const _preloadAboutOpen = new Image(); _preloadAboutOpen.src = aboutOpenSrc;
        const _preloadAboutClosed = new Image(); _preloadAboutClosed.src = aboutClosedSrc;
    } catch (e) { console.debug('Preload failed:', e); }

    // pageRoot wrapper so fixed UI (audio control) stays outside grayscale
    const pageRoot = document.querySelector('.page-root');

    // Background audio fade-in on load
    const bgAudio = document.getElementById('background-music');
    if (bgAudio) {
        bgAudio.volume = 0;
        bgAudio.loop = true;
        // Try to play; catch autoplay policy rejections
        const playPromise = bgAudio.play();
        if (playPromise !== undefined) {
            playPromise.then(() => {
                // Fade in
                const fadeInDuration = 1000; // ms
                const fadeInInterval = 50;
                const steps = fadeInDuration / fadeInInterval;
                let currentStep = 0;
                const targetVolume = 0.18; // gentle background volume
                const fadeTimer = setInterval(() => {
                    currentStep++;
                    const progress = currentStep / steps;
                    bgAudio.volume = targetVolume * progress;
                    if (progress >= 1) {
                        clearInterval(fadeTimer);
                        bgAudio.volume = targetVolume;
                    }
                }, fadeInInterval);
            }).catch((err) => {
                console.debug('Autoplay prevented:', err);
            });
        }
    }

    avatarImage.addEventListener('click', function(e) {
        console.log('Avatar clicked!', e);
        isExpanded = !isExpanded;
        console.log('isExpanded:', isExpanded);
        
    if (isExpanded) {
            // Switch to about me avatar
            avatarImage.src = 'images/aboutmeimages/fullbodyiconabout-transparent.png';
            avatarImageClosed.src = 'images/aboutmeimages/fullbodyiconaboutclosed-transparent.png';
            
            // Shift avatar and show content
            avatarContainer.classList.add('shifted');
            contentBlock.classList.add('active');

            // Ensure content sections that are already in view reveal after the
            // content block has finished its show transition. Using transitionend
            // avoids measuring visibility while the block is still translated off-screen.
            if (typeof revealContentSectionsNow === 'function') {
                const onTransition = (ev) => {
                    // wait for transform or opacity transition to finish
                    if (ev.propertyName === 'transform' || ev.propertyName === 'opacity') {
                        revealContentSectionsNow();
                    }
                };
                // Attach one-time listener; if transitionend doesn't fire, fallback after 900ms
                contentBlock.addEventListener('transitionend', onTransition, { once: true });
                setTimeout(() => { try { revealContentSectionsNow(); } catch (e) { /* noop */ } }, 900);
            }
            
            // Add color mode (no visual change as grayscale removed)
            console.log('Adding color-mode class');
            if (pageRoot) pageRoot.classList.add('color-mode');
            // Also mark the background video as colored
            if (backgroundVideo) backgroundVideo.classList.add('color');
            // Also add color-mode to container for compatibility with homepage rules
            const containerEl = document.querySelector('.container');
            if (containerEl) containerEl.classList.add('color-mode');
            // Show dropdown button when avatar expands (button must be clicked to open menu)
            dropdownMenu.classList.add('visible');
            console.log('PageRoot classes:', pageRoot ? pageRoot.className : '(none)');
        } else {
            // Switch back to smiling homepage avatar
            avatarImage.src = 'images/homeimages/fullbodyiconsmile-transparent.png';
            avatarImageClosed.src = 'images/homeimages/fullbodyiconsmileclosed-transparent.png';

            // Move avatar back and hide content
            avatarContainer.classList.remove('shifted');
            contentBlock.classList.remove('active');

            // Force a reflow so the browser registers the transform change immediately.
            // Then remove the color-mode and video color on the next animation frame.
            void document.body.offsetWidth;

            requestAnimationFrame(() => {
                console.log('Removing color-mode class (deferred)');
                if (pageRoot) pageRoot.classList.remove('color-mode');
                // Remove color class from background video when collapsing
                if (backgroundVideo) backgroundVideo.classList.remove('color');
                // Also remove color-mode from container
                const containerEl = document.querySelector('.container');
                if (containerEl) containerEl.classList.remove('color-mode');
                // Close the open dropdown content when avatar collapses, but keep
                // the dropdown button visible so the user can still open the menu.
                dropdownMenu.classList.remove('menu-open');
                console.log('PageRoot classes:', pageRoot ? pageRoot.className : '(none)');
            });

            // Do NOT trigger the fullscreen closing outro when simply collapsing avatar.
            // The outro should run only when navigating away (dropdown links). Keep local revert behavior.
        }
    });

    // Also make closed avatar clickable
    avatarImageClosed.addEventListener('click', function() {
        avatarImage.click();
    });

    // Parallax effect - background follows cursor
    const backgroundVideo = document.querySelector('.background-video');
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const maxOffset = 5; // Very small movement to avoid gaps
    
    document.addEventListener('mousemove', (e) => {
        const centerX = windowWidth / 2;
        const centerY = windowHeight / 2;
        
        // Calculate how far the cursor is from center (-1 to 1)
        const offsetX = (e.clientX - centerX) / centerX;
        const offsetY = (e.clientY - centerY) / centerY;
        
        // Calculate translation (move background opposite to cursor direction)
        const translateX = offsetX * maxOffset;
        const translateY = offsetY * maxOffset;
        
    // Apply transform to background video (preserve the zoom scale)
    backgroundVideo.style.transform = `translate(${translateX}px, ${translateY}px) scale(1.06)`;
    });


    // Passive background audio playback (no visible UI). Keep gentle default volume.
    if (bgAudio) {
        try { bgAudio.volume = 0.18; } catch(e) {}
        // Attempt to play on user interactions to satisfy autoplay policies, but no visible UI is provided.
        const _tryStart = () => { try { bgAudio.play().catch(()=>{}); } catch(e){} };
        document.addEventListener('mousemove', _tryStart, { once: true });
        document.addEventListener('touchstart', _tryStart, { once: true });
        document.addEventListener('click', _tryStart, { once: true });
        document.addEventListener('keydown', _tryStart, { once: true });
        setTimeout(_tryStart, 1500);
        bgAudio.addEventListener('ended', () => { try { bgAudio.currentTime = 0; bgAudio.play().catch(()=>{}); } catch(e){} });
    }

    // Volume UI removed - no volume slider or button handlers

    // Restrict the background video to the first 90 seconds (1min30s)
    (function limitAboutBackgroundSegment(){
        try {
            const fg = document.querySelector('.background-video');
            if (!fg) return;
            const SEGMENT_END = 90; // seconds

            function onLoadedMeta(v) {
                if (v.duration && v.duration <= SEGMENT_END) return false;
                v.currentTime = 0;
                v.play().catch(()=>{});
                return true;
            }

            if (fg) fg.addEventListener('loadedmetadata', () => onLoadedMeta(fg));

            // Use a single timer driven by the foreground video to reset both players
            fg.addEventListener('timeupdate', () => {
                try {
                    if (fg.currentTime >= SEGMENT_END - 0.15) {
                        // reset video to 0 and play
                        fg.currentTime = 0;
                        fg.play().catch(()=>{});
                    }
                } catch (e) { /* ignore */ }
            });
        } catch (e) { console.debug('Could not limit about background segment:', e); }
    })();

    // Scroll-reveal observer for content sections inside the content block.
    (function setupContentSectionObserver(){
        const contentBlockEl = document.getElementById('contentBlock');
        if (!contentBlockEl) return;

    // target both headings and content-section blocks so headings reveal as well
    const sections = Array.from(contentBlockEl.querySelectorAll('.content-section, h2, h3'));
    if (!sections.length) return;

        // Root is the contentBlock so we observe intersection inside the scroll container
        const observer = new IntersectionObserver((entries, obs) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const el = entry.target;
                    // Add visible with a slight stagger based on index to make it feel like a dropdown
                    const idx = sections.indexOf(el);
                    setTimeout(() => el.classList.add('visible'), Math.min(300, idx * 60));
                    obs.unobserve(el);
                }
            });
        }, {
            root: contentBlockEl,
            rootMargin: '0px 0px -12px 0px',
            threshold: 0.08
        });

        // Make content-section elements keyboard-focusable (so :focus-within can apply)
        sections.forEach(s => {
            if (s.classList && s.classList.contains('content-section')) {
                s.setAttribute('tabindex', '0');
            }
            observer.observe(s);
        });
    })();

    // Synchronous reveal helper for the moment the content block becomes visible.
    // This complements the IntersectionObserver: when the block opens we may need
    // to reveal the currently-visible sections immediately (avoids missing the
    // initial entrance if intersection events don't fire during the activation animation).
    function revealContentSectionsNow(){
        const contentBlockEl = document.getElementById('contentBlock');
        if (!contentBlockEl) return;
    const sections = Array.from(contentBlockEl.querySelectorAll('.content-section, h2, h3'));
    if (!sections.length) return;

        const rootRect = contentBlockEl.getBoundingClientRect();
        sections.forEach((el, idx) => {
            if (el.classList.contains('visible')) return; // already revealed
            const r = el.getBoundingClientRect();
            // Determine visibility relative to the content block viewport
            const top = r.top - rootRect.top;
            const bottom = r.bottom - rootRect.top;
            const isVisible = (top < contentBlockEl.clientHeight) && (bottom > 0);
            if (isVisible) {
                setTimeout(() => el.classList.add('visible'), Math.min(300, idx * 60));
            }
        });
    }
</script>
</html>
